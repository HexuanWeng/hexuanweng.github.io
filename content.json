{"meta":{"title":"Hex.*","subtitle":"","description":"","author":"Hexuan Weng","url":"http://hexuanweng.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2024-06-28T06:31:58.741Z","updated":"2024-06-28T06:31:58.741Z","comments":false,"path":"/404.html","permalink":"http://hexuanweng.github.io/404.html","excerpt":"","text":"404 true"},{"title":"About Me","date":"2024-06-28T06:31:59.479Z","updated":"2024-06-28T06:31:59.479Z","comments":false,"path":"about/index.html","permalink":"http://hexuanweng.github.io/about/index.html","excerpt":"","text":"About Me"},{"title":"Tags","date":"2020-10-23T12:13:46.000Z","updated":"2020-10-23T12:13:46.000Z","comments":false,"path":"tags/index.html","permalink":"http://hexuanweng.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-05-27T03:47:40.000Z","updated":"2017-05-27T03:47:40.000Z","comments":false,"path":"categories/index.html","permalink":"http://hexuanweng.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"How to Change the Owner of Power Apps Apps","slug":"PowerAppsOwnerChange","date":"2024-08-02T14:00:00.000Z","updated":"2024-08-02T14:00:00.000Z","comments":true,"path":"2024/08/03/PowerAppsOwnerChange/","permalink":"http://hexuanweng.github.io/2024/08/03/PowerAppsOwnerChange/","excerpt":"","text":"Gathering Information Needed To Change The Power Apps App OwnerTo change the owner of a Power Apps app we will need to gather 3 pieces of information: Environment ID from the Power Apps maker portal App ID from the Power Apps maker portal User Account Object ID from Azure Active Directory Obtain The Environment IDOpen make.powerapps.com and open the settings menu. Choose developer resources. The Environment ID will appear in the developer resources menu： 6955xxxx-fxxx-4xxx-axxx-2bxxxxxxxxxx Get The Power Apps App IDGo to the Apps menu in the maker portal, select the three dots beside the app then click Details. The App ID will appear in the Details menu： edxxxxxx-5xxx-4xxx-axxx-66xxxxxxxxxx Currently, you can see the Owner of the App is Hexuan Weng. Find The New Owner’s User Account Object IDLogin to portal.azure.com and search for the user account you want to transfer ownership to. In this case we will make a user called Power Platform Service Account the Owner. The Object ID will appear in the user’s profile. dexxxxxx-fxxx-4xxx-8xxx-f1xxxxxxxxxx Method 1: Change Power Apps App Owner With A FlowThe first way we can change the owner of a Power Apps app is by building a flow to transfer ownership. Create a new Power Automate flow with an instant trigger. Name the flow Change App Owner, select Manually trigger a flow then click Create. Add the flow action Power Apps For Admins – Set App Owner with the following parameters and fill in the environment name, Power App Name and New PowerApp Owner with the unique identifiers we gathered earlier. Run the flow. The Power Platform Service Account now owns the app. Method 2: Change Power Apps App Owner With PowerShellIf you like to use PowerShell for automating administrative tasks there is a robust library of Power Apps cmdlets including a cmdlet to set the Power App owner. Open the Windows PowerShell ISE and Run as administrator. Create a new script called ChangeAppOwner.ps1… …and paste the following code into the text editor. Switch the environment name, app name and new app owner with your own information then press the green play button to execute the script. 12345$EnvironmentName = &#x27;6955xxxx-fxxx-4xxx-axxx-2bxxxxxxxxxx&#x27;$AppName = &#x27;edxxxxxx-5xxx-4xxx-axxx-66xxxxxxxxxx&#x27;$NewAppOwner = &#x27;dexxxxxx-fxxx-4xxx-8xxx-f1xxxxxxxxxx&#x27;Set-AdminPowerAppOwner –AppName $AppName -AppOwner $NewAppOwner –EnvironmentName $EnvironmentName Error There are a couple of possibilites You need to be a Global Admin or AAD Admin in the tenant to run the “Admin” commands. Are you a global admin? Are you supplying the GUIDS for the Appname, Environment, and AppOwner? The examples all show guids, rather than just names. Method 3: Change Power Apps App Owner Using The Center Of Excellence Starter KitThe Power Apps Center Of Excellence Starter Kit offers the easiest way to change a Power Apps App owner. Open the canvas app called Admin – App Permission Center that is included in the CoE Starter Kit. Browse to the app’s environment, select the app from the list and then click Add Permissions. 1.Power Apps cmdlets ↩2.Power Apps Center Of Excellence Starter Kit ↩","categories":[{"name":"Microsoft Power Platform","slug":"Microsoft-Power-Platform","permalink":"http://hexuanweng.github.io/categories/Microsoft-Power-Platform/"}],"tags":[{"name":"Power Apps","slug":"Power-Apps","permalink":"http://hexuanweng.github.io/tags/Power-Apps/"}]},{"title":"LC998 - Maximum Binary Tree II","slug":"LC998MaximumBinaryTreeII","date":"2022-08-30T02:00:07.000Z","updated":"2022-08-30T02:00:07.000Z","comments":true,"path":"2022/08/30/LC998MaximumBinaryTreeII/","permalink":"http://hexuanweng.github.io/2022/08/30/LC998MaximumBinaryTreeII/","excerpt":"","text":"DescriptionA maximum tree is a tree where every node has a value greater than any other value in its subtree.You are given the root of a maximum binary tree and an integer val.Just as in the previous problem, the given tree was constructed from a list a (root &#x3D; Construct(a)) recursively with the following Construct(a) routine:If a is empty, return null.Otherwise, let a[i] be the largest element of a. Create a root node with the value a[i].The left child of root will be Construct([a[0], a[1], …, a[i - 1]]).The right child of root will be Construct([a[i + 1], a[i + 2], …, a[a.length - 1]]).Return root.Note that we were not given a directly, only a root node root &#x3D; Construct(a).Suppose b is a copy of a with the value val appended to it. It is guaranteed that b has unique values.Return Construct(b). Example 1: Input: root = [4,1,3,null,null,2], val = 5 Output: [5,4,null,1,3,null,null,2] Explanation: a = [1,4,2,3], b = [1,4,2,3,5] 12Example 2:&#123;% asset_img e2.jpg e2%&#125; Input: root = [5,2,4,null,1], val = 3 Output: [5,2,4,null,1,null,3] Explanation: a = [2,1,5,4], b = [2,1,5,4,3] 12Example 3:&#123;% asset_img e3.jpg e3%&#125; Input: root = [5,2,3,null,1], val = 4 Output: [5,2,4,null,1,3] Explanation: a = [2,1,5,3], b = [2,1,5,3,4] 12Constraints: The number of nodes in the tree is in the range [1, 100]. 1 &lt;= Node.val &lt;= 100 All the values of the tree are unique. 1 &lt;= val &lt;= 100 1234567891011121314151617181920212223242526## SolutionBecause the new val is added at the end of the array, we can compare with the root node,- If it is larger than the root, then val is the new root and the original root is its left subtree (since val is to the right of the original root&#x27;s value in the array).- If it is smaller than the root node, it means that val must be recursively added to the right node of the original root. Note that recursion may change the root of the right subtree, so reassign the right node of the root node.Finally, if the recursive root is empty, a new leaf node can be returned directly.```python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]: if not root: return TreeNode(val) if val &gt; root.val: cur = TreeNode(val) cur.left = root return cur root.right = self.insertIntoMaxTree(root.right, val) return root &lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style: none; padding-left: 0; margin-left: 40px&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; margin-left: 10px;&quot;&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-binary-tree-ii/&quot;&gt;998. Maximum Binary Tree II&lt;/a&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Recursion","slug":"Recursion","permalink":"http://hexuanweng.github.io/tags/Recursion/"}]},{"title":"LC654 - Maximum Binary Tree","slug":"LC654MaximumBinaryTree","date":"2022-08-30T01:39:34.000Z","updated":"2022-08-30T01:39:34.000Z","comments":true,"path":"2022/08/30/LC654MaximumBinaryTree/","permalink":"http://hexuanweng.github.io/2022/08/30/LC654MaximumBinaryTree/","excerpt":"","text":"DescriptionYou are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm: Create a root node whose value is the maximum value in nums. Recursively build the left subtree on the subarray prefix to the left of the maximum value. Recursively build the right subtree on the subarray suffix to the right of the maximum value.Return the maximum binary tree built from nums. Example 1: 123456789101112Input: nums = [3,2,1,6,0,5]Output: [6,3,5,null,2,0,null,null,1]Explanation: The recursive calls are as follow:- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5]. - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1]. - Empty array, so no child. - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1]. - Empty array, so no child. - Only one element, so child is a node with value 1. - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is []. - Only one element, so child is a node with value 0. - Empty array, so no child. Example 2: 12Input: nums = [3,2,1]Output: [3,null,2,null,1] Constraints: 1231 &lt;= nums.length &lt;= 10000 &lt;= nums[i] &lt;= 1000All integers in nums are unique. Solution 12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def constructMaximumBinaryTree(self, nums: List[int]) -&gt; Optional[TreeNode]: def dfs(arr): if not arr: return None root = max(arr) idx = arr.index(root) return TreeNode(root, dfs(arr[:idx]), dfs(arr[idx+1:])) return dfs(nums) 1.654. Maximum Binary Tree ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Recursion","slug":"Recursion","permalink":"http://hexuanweng.github.io/tags/Recursion/"}]},{"title":"LC318 - Maaximum Product of Word Lengths","slug":"LC318MaaximumProductofWordLengths","date":"2022-08-28T20:34:19.000Z","updated":"2022-08-28T20:34:19.000Z","comments":true,"path":"2022/08/29/LC318MaaximumProductofWordLengths/","permalink":"http://hexuanweng.github.io/2022/08/29/LC318MaaximumProductofWordLengths/","excerpt":"","text":"DescriptionGiven a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0. Example 1: 123Input: words = [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]Output: 16Explanation: The two words can be &quot;abcw&quot;, &quot;xtfn&quot;. Example 2: 123Input: words = [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]Output: 4Explanation: The two words can be &quot;ab&quot;, &quot;cd&quot;. Example 3: 123Input: words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]Output: 0Explanation: No such pair of words. Constraints: 1232 &lt;= words.length &lt;= 10001 &lt;= words[i].length &lt;= 1000words[i] consists only of lowercase English letters. Solution create a list called s to store all the individual letter of each word using two for loops to compare each two words in the list, if there is no common letter, update the answer 1234567891011121314# O(n^2) time | O(n) spaceclass Solution: def maxProduct(self, words: List[str]) -&gt; int: ans = 0 d = [] for word in words: d.append(set(list(word))) for i in range(len(words)): for j in range(i+1, len(words)): if not d[i] &amp; d[j]: ans = max(ans, len(words[i])*len(words[j])) return ans 1.318. Maximum Product of Word Lengths ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Brute Force","slug":"Brute-Force","permalink":"http://hexuanweng.github.io/tags/Brute-Force/"}]},{"title":"LC1470 - Shuffle the Array","slug":"LC1470Shuffle","date":"2022-08-28T19:49:53.000Z","updated":"2022-08-28T19:49:53.000Z","comments":true,"path":"2022/08/29/LC1470Shuffle/","permalink":"http://hexuanweng.github.io/2022/08/29/LC1470Shuffle/","excerpt":"","text":"DescriptionGiven the array nums consisting of 2n elements in the form [x1,x2,…,xn,y1,y2,…,yn].Return the array in the form [x1,y1,x2,y2,…,xn,yn]. Example 1: 123Input: nums = [2,5,1,3,4,7], n = 3Output: [2,3,5,4,1,7] Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. Example 2: 12Input: nums = [1,2,3,4,4,3,2,1], n = 4Output: [1,4,2,3,3,2,4,1] Example 3: 12Input: nums = [1,1,2,2], n = 2Output: [1,2,1,2] Constraints: 1231 &lt;= n &lt;= 500nums.length == 2n1 &lt;= nums[i] &lt;= 10^3 Solution slow index: i, faster index: j initial i &#x3D; 0, j &#x3D; n when j reaches to the end, i reaches the end of the first half of this array 12345678910# O(n) time | O(n) spaceclass Solution: def shuffle(self, nums: List[int], n: int) -&gt; List[int]: i, j = 0, n ans = [] for j in range(n, len(nums)): ans.append(nums[i]) ans.append(nums[j]) i += 1 return ans 1.1470. Shuffle the Array ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://hexuanweng.github.io/tags/Two-Pointers/"}]},{"title":"LC662 - Maximum Width of Binary Tree","slug":"LC662MaximumWidthofBinaryTree","date":"2022-08-27T13:30:35.000Z","updated":"2022-08-27T13:30:35.000Z","comments":true,"path":"2022/08/27/LC662MaximumWidthofBinaryTree/","permalink":"http://hexuanweng.github.io/2022/08/27/LC662MaximumWidthofBinaryTree/","excerpt":"","text":"DescriptionGiven the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. It is guaranteed that the answer will in the range of a 32-bit signed integer. Example 1: 123Input: root = [1,3,2,5,3,null,9]Output: 4Explanation: The maximum width exists in the third level with length 4 (5,3,null,9). Example 2: 123Input: root = [1,3,2,5,null,null,9,6,null,7]Output: 7Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7). Example 3: 123Input: root = [1,3,2,5]Output: 2Explanation: The maximum width exists in the second level with length 2 (3,2). Constraints: 12The number of nodes in the tree is in the range [1, 3000].-100 &lt;= Node.val &lt;= 100 SoutionUsing the full binary tree number, the distance between any two nodes in the same layer (with empty nodes) can be easily calculated, and our BFS returns the layer with the largest distance between the leftmost and the rightmost. 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightfrom collections import dequeclass Solution: def widthOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int: ans = 0 queue = deque([(1, root)]) while queue: l, r = float(&#x27;inf&#x27;), 0 for _ in range(len(queue)): idx, popnode = queue.popleft() if popnode.left: queue.append((idx*2, popnode.left)) if popnode.right: queue.append((idx*2+1, popnode.right)) l, r = min(idx, l), max(idx, r) ans = max(ans, r-l+1) return ans#Runtime: 42 ms, faster than 97.03% of Python3 online submissions for Maximum Width of Binary Tree.#Memory Usage: 14.8 MB, less than 46.14% of Python3 online submissions for Maximum Width of Binary Tree. 1.662. Maximum Width of Binary Tree ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"LC1464 - Maximum Product of Two Elements in an Array","slug":"LC1464MaximumProductofTwoElementsinanArray","date":"2022-08-25T19:25:18.000Z","updated":"2022-08-25T19:25:18.000Z","comments":true,"path":"2022/08/26/LC1464MaximumProductofTwoElementsinanArray/","permalink":"http://hexuanweng.github.io/2022/08/26/LC1464MaximumProductofTwoElementsinanArray/","excerpt":"","text":"DescriptionGiven the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1). Example 1: 123Input: nums = [3,4,5,2]Output: 12 Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. Example 2: 123Input: nums = [1,5,4,5]Output: 16Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16. Example 3: 12Input: nums = [3,7]Output: 12 Constraints: 122 &lt;= nums.length &lt;= 5001 &lt;= nums[i] &lt;= 10^3 SolutionsSorting Sort first then the last two values ​​are the largest two values find the final answer as required and return 12345# O(nlogn) time | O(1) spaceclass Solution: def maxProduct(self, nums: List[int]) -&gt; int: nums.sort() return (nums[-1]-1)*(nums[-2]-1) Two PointersThis problem is actually to find the first and second largest numbers in the array. We only need to use first and second to represent the subscripts of the first and second largest numbers, and then traverse the array and compare them one by one. 1234567891011121314# O(n) time | O(1) spaceclass Solution: def maxProduct(self, nums: List[int]) -&gt; int: first, second = 0, 1 if nums[second] &gt; nums[first]: first, second = 1, 0 for i in range(2, len(nums)): v = nums[i] if v &gt; nums[first]: first, second = i, first elif v &gt; nums[second]: second = i return (nums[first]-1)*(nums[second]-1) 1.1464. Maximum Product of Two Elements in an Array ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://hexuanweng.github.io/tags/Two-Pointers/"}]},{"title":"LC658 - Find K Closest Elements","slug":"LC658FindKClosestElements","date":"2022-08-25T08:36:23.000Z","updated":"2022-08-25T08:36:23.000Z","comments":true,"path":"2022/08/25/LC658FindKClosestElements/","permalink":"http://hexuanweng.github.io/2022/08/25/LC658FindKClosestElements/","excerpt":"","text":"DescriptionGiven a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order. An integer a is closer to x than an integer b if: 12|a - x| &lt; |b - x|, or|a - x| == |b - x| and a &lt; b Example 1: 12Input: arr = [1,2,3,4,5], k = 4, x = 3Output: [1,2,3,4] Example 2: 12Input: arr = [1,2,3,4,5], k = 4, x = -1Output: [1,2,3,4] Constraints: 12341 &lt;= k &lt;= arr.length1 &lt;= arr.length &lt;= 104arr is sorted in ascending order.-104 &lt;= arr[i], x &lt;= 104 SolutionsThe answer must be a continuous window; numbers are excluded from the left and right ends of the window, leaving k numbers at the end 1234567891011121314151617# O(n) time | O(1) spaceclass Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]: n = len(arr) left, right = 0, n-1 remaining = n - k ans = [] for _ in range(remaining): if abs(arr[left] - x) &gt; abs(arr[right] - x): left +=1 else: right -=1 for i in range(left, right+1): ans.append(arr[i]) return ans 1.658. Find K Closest Elements ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://hexuanweng.github.io/tags/Two-Pointers/"}]},{"title":"LC240 - Search a 2D Matrix II","slug":"LC240SearchA2DMatrixII","date":"2022-08-13T15:26:57.000Z","updated":"2022-08-13T15:26:57.000Z","comments":true,"path":"2022/08/14/LC240SearchA2DMatrixII/","permalink":"http://hexuanweng.github.io/2022/08/14/LC240SearchA2DMatrixII/","excerpt":"","text":"DescriptionWrite an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:Integers in each row are sorted in ascending from left to right.Integers in each column are sorted in ascending from top to bottom. Example 1: 12Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5Output: true Example 2: 12Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20Output: false Constraints: 1234567m == matrix.lengthn == matrix[i].length1 &lt;= n, m &lt;= 300-109 &lt;= matrix[i][j] &lt;= 109All the integers in each row are sorted in ascending order.All the integers in each column are sorted in ascending order.-109 &lt;= target &lt;= 109 SolutionBFSStart the search from the upper right corner search down if it is smaller than the target search to the left if it is larger than the target) 1234567891011121314151617181920212223class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: m, n = len(matrix), len(matrix[0]) queue = deque([(0,n-1)]) visited = set() while queue: x, y = queue.popleft() cur_val = matrix[x][y] if cur_val == target: return True if cur_val &lt; target: nx, ny = x+1, y if 0&lt;= nx &lt; m and 0&lt;= ny &lt; n and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) else: nx, ny = x, y-1 if 0&lt;= nx &lt; m and 0&lt;= ny &lt; n and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False 1.240. Search a 2D Matrix II ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"LC1282 - Group the People Given the Group Size They Belong To","slug":"LC1282GroupthePeopleGiventheGroupSizeTheyBelongTo","date":"2022-08-12T02:15:23.000Z","updated":"2022-08-12T02:15:23.000Z","comments":true,"path":"2022/08/12/LC1282GroupthePeopleGiventheGroupSizeTheyBelongTo/","permalink":"http://hexuanweng.github.io/2022/08/12/LC1282GroupthePeopleGiventheGroupSizeTheyBelongTo/","excerpt":"","text":"DescriptionThere are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1.You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] &#x3D; 3, then person 1 must be in a group of size 3.Return a list of groups such that each person i is in a group of size groupSizes[i].Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input. Example 1: 1234567Input: groupSizes = [3,3,3,3,3,1,3]Output: [[5],[0,1,2],[3,4,6]]Explanation: The first group is [5]. The size is 1, and groupSizes[5] = 1.The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]]. Example 2: 12Input: groupSizes = [2,1,3,3,3,2]Output: [[1],[0,5],[2,3,4]] Constraints: 123groupSizes.length == n1 &lt;= n &lt;= 5001 &lt;= groupSizes[i] &lt;= n Solutions key: length of the group, value: the index of each element store them in the dictionary for loop value and use v[i:i+k] to slice the string based on the key 123456789101112131415161718192021from sortedcontainers import SortedListclass Solution: def groupThePeople(self, groupSizes: List[int]) -&gt; List[List[int]]: new_group = SortedList() for i, v in enumerate(groupSizes): new_group.add((v,i)) # print(new_group) i = 0 ans = [] while i &lt; len(groupSizes): size, y = new_group[i] group = [] for s in range(size): group.append(new_group[i+s][1]) i = i+s+1 ans.append(group) return ans#Runtime: 234 ms, faster than 5.20% of Python3 online submissions for Group the People Given the Group Size They Belong To.#Memory Usage: 14.5 MB, less than 17.57% of Python3 online submissions for Group the People Given the Group Size They Belong To. Optimised HashTable 123456789101112131415class Solution: def groupThePeople(self, groupSizes: List[int]) -&gt; List[List[int]]: ans = [] mp = defaultdict(list) for i, v in enumerate(groupSizes): mp[v].append(i) for k, v in mp.items(): for i in range(0, len(v), k): ans.append(v[i:i+k]) return ans#Runtime: 89 ms, faster than 82.67% of Python3 online submissions for Group the People Given the Group Size They Belong To.#Memory Usage: 13.9 MB, less than 88.49% of Python3 online submissions for Group the People Given the Group Size They Belong To. 1.1282. Group the People Given the Group Size They Belong To ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Hashmap","slug":"Hashmap","permalink":"http://hexuanweng.github.io/tags/Hashmap/"}]},{"title":"LC1417 - Reformat the String","slug":"LC1417ReformatTheString","date":"2022-08-11T14:25:45.000Z","updated":"2022-08-11T14:25:45.000Z","comments":true,"path":"2022/08/12/LC1417ReformatTheString/","permalink":"http://hexuanweng.github.io/2022/08/12/LC1417ReformatTheString/","excerpt":"","text":"DescriptionYou are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits).You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.Return the reformatted string or return an empty string if it is impossible to reformat the string. Example 1: 123Input: s = &quot;a0b1c2&quot;Output: &quot;0a1b2c&quot;Explanation: No two adjacent characters have the same type in &quot;0a1b2c&quot;. &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; are also valid permutations. Example 2: 123Input: s = &quot;leetcode&quot;Output: &quot;&quot;Explanation: &quot;leetcode&quot; has only characters so we cannot separate them by digits. Example 3: 123Input: s = &quot;1229857369&quot;Output: &quot;&quot;Explanation: &quot;1229857369&quot; has only digits so we cannot separate them by characters. Constraints: 121 &lt;= s.length &lt;= 500s consists of only lowercase English letters and/or digits. Solutions Traverse s and store letters and numbers in two different lists: nums, letters If the difference between the lengths of len(nums) and len(letters) is greater than 1, return “” directly If len(nums) ≥ len(letters), append the value of nums first in the result, and vice versa If there are remaining values, append to ans 1234567891011121314151617181920212223242526272829# O(n) time | O(n) spaceclass Solution: def reformat(self, s: str) -&gt; str: nums, letters = [], [] ans = [] for i in s: if i.isdigit(): nums.append(i) else: letters.append(i) # print(nums, letters) if abs(len(nums) - len(letters)) &gt; 1: return &quot;&quot; else: i = 0 while i &lt;min(len(nums), len(letters)): if len(nums) &gt;= len(letters): ans.append(nums[i]) ans.append(letters[i]) else: ans.append(letters[i]) ans.append(nums[i]) i+=1 if i &lt; len(nums): ans.append(nums[-1]) if i &lt; len(letters): ans.append(letters[-1]) return &quot;&quot;.join(ans) 1.1417. Reformat The String ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Simulation","slug":"Simulation","permalink":"http://hexuanweng.github.io/tags/Simulation/"}]},{"title":"LC640 - Solve the Equation","slug":"LC640SolvetheEquation","date":"2022-08-10T12:47:12.000Z","updated":"2022-08-10T12:47:12.000Z","comments":true,"path":"2022/08/10/LC640SolvetheEquation/","permalink":"http://hexuanweng.github.io/2022/08/10/LC640SolvetheEquation/","excerpt":"","text":"DescriptionSolve a given equation and return the value of ‘x’ in the form of a string “x&#x3D;#value”. The equation contains only ‘+’, ‘-‘ operation, the variable ‘x’ and its coefficient. You should return “No solution” if there is no solution for the equation, or “Infinite solutions” if there are infinite solutions for the equation.If there is exactly one solution for the equation, we ensure that the value of ‘x’ is an integer. Example 1: 12Input: equation = &quot;x+5-3+x=6+x-2&quot;Output: &quot;x=2&quot; Example 2: 12Input: equation = &quot;x=x&quot;Output: &quot;Infinite solutions&quot; Example 3: 12Input: equation = &quot;2x=x&quot;Output: &quot;x=0&quot; Constraints: 1233 &lt;= equation.length &lt;= 1000equation has exactly one &#x27;=&#x27;.equation consists of integers with an absolute value in the range [0, 100] without any leading zeros, and the variable &#x27;x&#x27;. Solution Move all expressions to the left Then all minus signs are preceded by a plus sign as a prefix Divide the equation by plus sign Count the number of x and the operation result of the number Get results based on the requirements 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution: def solveEquation(self, equation: str) -&gt; str: left, right = equation.split(&quot;=&quot;) new_left = [] new_right = [] if right[0] != &quot;-&quot;: right = &quot;+&quot; + right for i in range(len(left)): if left[i] == &quot;-&quot;: new_left.append(&quot;+-&quot;) else: new_left.append(left[i]) for i in range(len(right)): if right[i] == &quot;+&quot;: new_right.append(&quot;+-&quot;) elif right[i] == &quot;-&quot;: new_right.append(&quot;+&quot;) else: new_right.append(right[i]) e = &quot;&quot;.join(new_left)+&quot;&quot;.join(new_right) print(e.split(&quot;+&quot;)) letter = 0 num = 0 for cur in e.split(&quot;+&quot;): sign, coe, l = 1, 0, 0 if cur: if cur[0] == &quot;-&quot;: sign = -1 if cur[-1] == &quot;x&quot;: coe = int(cur[1:-1]) if len(cur) &gt; 2 else 1 letter += sign * coe else: num += int(cur) else: if cur[-1] == &quot;x&quot;: coe = int(cur[:-1]) if len(cur) &gt; 1 else 1 letter += sign * coe else: num += int(cur) if letter == num == 0: return &quot;Infinite solutions&quot; elif letter == 0 and num != 0: return &quot;No solution&quot; else: v = int(-num / letter) return &quot;x=&quot;+str(v) 1.640. Solve the Equation ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Simulation","slug":"Simulation","permalink":"http://hexuanweng.github.io/tags/Simulation/"}]},{"title":"LC1413 - Minimum Value to Get Positive Step by Step Sum","slug":"LC1413MinimumValuetoGetPositiveStepbyStepSum","date":"2022-08-09T11:12:04.000Z","updated":"2022-08-09T11:12:04.000Z","comments":true,"path":"2022/08/09/LC1413MinimumValuetoGetPositiveStepbyStepSum/","permalink":"http://hexuanweng.github.io/2022/08/09/LC1413MinimumValuetoGetPositiveStepbyStepSum/","excerpt":"","text":"DescriptionGiven an array of integers nums, you start with an initial positive value startValue.In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right).Return the minimum positive value of startValue such that the step by step sum is never less than 1. Example 1: 12345678910Input: nums = [-3,2,-3,4,2]Output: 5Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.step by step sumstartValue = 4 | startValue = 5 | nums (4 -3 ) = 1 | (5 -3 ) = 2 | -3 (1 +2 ) = 3 | (2 +2 ) = 4 | 2 (3 -3 ) = 0 | (4 -3 ) = 1 | -3 (0 +4 ) = 4 | (1 +4 ) = 5 | 4 (4 +2 ) = 6 | (5 +2 ) = 7 | 2 Example 2: 123Input: nums = [1,2]Output: 1Explanation: Minimum start value should be positive. Example 3: 12Input: nums = [1,-2,-3]Output: 5 Constraints: 121 &lt;= nums.length &lt;= 100-100 &lt;= nums[i] &lt;= 100 SolutionThe smallest positive integer is required.We can get the smallest negative sum, and the answer is the opposite of the negative number + 1 12345678910# O(n) time | O(1) spaceclass Solution: def minStartValue(self, nums: List[int]) -&gt; int: ans = 0 cur = 0 for i in nums: cur += i if cur &lt; ans: ans = cur return -ans + 1 1.1413. Minimum Value to Get Positive Step by Step Sum ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Greedy","slug":"Greedy","permalink":"http://hexuanweng.github.io/tags/Greedy/"}]},{"title":"LC1374 - Generate a String With Characters That Have Odd Counts","slug":"LC1374GenerateaStringWithCharactersThatHaveoddCounts","date":"2022-08-01T11:39:23.000Z","updated":"2022-08-01T11:39:23.000Z","comments":true,"path":"2022/08/01/LC1374GenerateaStringWithCharactersThatHaveoddCounts/","permalink":"http://hexuanweng.github.io/2022/08/01/LC1374GenerateaStringWithCharactersThatHaveoddCounts/","excerpt":"","text":"DescriptionGiven an integer n, return a string with n characters such that each character in such string occurs an odd number of times.The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them. Example 1: 123Input: n = 4Output: &quot;pppz&quot;Explanation: &quot;pppz&quot; is a valid string since the character &#x27;p&#x27; occurs three times and the character &#x27;z&#x27; occurs once. Note that there are many other valid strings such as &quot;ohhh&quot; and &quot;love&quot;. Example 2: 123Input: n = 2Output: &quot;xy&quot;Explanation: &quot;xy&quot; is a valid string since the characters &#x27;x&#x27; and &#x27;y&#x27; occur once. Note that there are many other valid strings such as &quot;ag&quot; and &quot;ur&quot;. Example 3: 12Input: n = 7Output: &quot;holasss&quot; Constraints: 11 &lt;= n &lt;= 500 Solutions When n is an odd number, you can use one character, which itself is an odd number of times; Two characters can be used when n is even, odd+odd&#x3D;even 123456class Solution: def generateTheString(self, n: int) -&gt; str: if n % 2 == 0: return &quot;a&quot;*(n-1)+&quot;b&quot; else: return &quot;a&quot;*n 1.1374. Generate a String With Characters That Have Odd Counts ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Simulation","slug":"Simulation","permalink":"http://hexuanweng.github.io/tags/Simulation/"}]},{"title":"LC1161 - Maximum Level Sum of a Binary Tree","slug":"LC1161MaximumLevelSumofaBinaryTree","date":"2022-08-01T11:23:49.000Z","updated":"2022-08-01T11:23:49.000Z","comments":true,"path":"2022/08/01/LC1161MaximumLevelSumofaBinaryTree/","permalink":"http://hexuanweng.github.io/2022/08/01/LC1161MaximumLevelSumofaBinaryTree/","excerpt":"","text":"DescriptionGiven the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.Return the smallest level x such that the sum of all the values of nodes at level x is maximal. Example 1: 1234567Input: root = [1,7,0,7,-8,null,null]Output: 2Explanation: Level 1 sum = 1.Level 2 sum = 7 + 0 = 7.Level 3 sum = 7 + -8 = -1.So we return the level with the maximum sum which is level 2. Example 2: 12Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]Output: 2 Constraints: 12The number of nodes in the tree is in the range [1, 104].-105 &lt;= Node.val &lt;= 105 SolutionBFS counts the sum of each layer, and returns the one with the largest sum and the smallest number of layers. 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightfrom collections import dequeclass Solution: def maxLevelSum(self, root: Optional[TreeNode]) -&gt; int: queue = deque([root]) maxi = float(&#x27;-inf&#x27;) level = 1 ans = 0 while queue: l = len(queue) summ = 0 for _ in range(l): cur = queue.popleft() summ += cur.val if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) if summ &gt; maxi: maxi = summ ans = level level+=1 return ans 1.1161. Maximum Level Sum of a Binary Tree ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"PyTorch Tutorial - Linear Regression With PyTorch","slug":"PyTorch-P5","date":"2022-07-26T13:11:22.000Z","updated":"2022-07-26T13:11:22.000Z","comments":true,"path":"2022/07/26/PyTorch-P5/","permalink":"http://hexuanweng.github.io/2022/07/26/PyTorch-P5/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import torch# step 1: prepare the datasetx_data = torch.tensor([[1.0],[2.0],[3.0]])y_data = torch.tensor([[2.0],[4.0],[6.0]])# step2: design model&quot;&quot;&quot;Our model class should inherit from torch.nn.Module, which is the base class for all of the neural networks.__init__() and forward() have to be implemented.class nn.Linear contains two Tensor components: weight and biasclass nn.Linear has implemented the magic method __call__(), which enable the instance of the class to be called like a function.therefore, model(data) can call the forward function&quot;&quot;&quot;class LinearModel(torch.nn.Module): def __init__(self): super(LinearModel, self).__init__() # (1, 1) is the sie of each input sample and output sample # parameters in this model: weights and bias # model: y = xm + b self.linear = torch.nn.Linear(1, 1) def forward(self, x): y_pred = self.linear(x) return y_predmodel = LinearModel()# step3: construct loss and optimizercriterion = torch.nn.MSELoss(size_average = False)optimizer = torch.optim.SGD(model.parameters(), lr = 0.01) #iterable of parameters to optimizer. model.parameters() can get all the parameters in the model# step4: training cycle - forward, backward, updatefor epoch in range(1000): y_pred = model(x_data) loss = criterion(y_pred, y_data) print(epoch, loss.item()) optimizer.zero_grad() # the grad will be accumulated, so before backward, we need to set the grad to zero loss.backward() # backward: autograd optimizer.step() # update w, bprint(&#x27;w=&#x27;, model.linear.weight.item())print(&#x27;b=&#x27;, model.linear.weight.item())# step5: test modelx_test = torch.tensor([4.0])y_test = model(x_test)print(&#x27;y_pred= &#x27;, y_test.data)# 980 3.610836074585677e-10# 981 3.6504843592410907e-10# 982 3.5726088754017837e-10# 983 3.4162894735345617e-10# 984 3.445990159889334e-10# 985 3.355609123900649e-10# 986 3.370388412804459e-10# 987 3.249738256272394e-10# 988 3.1610625228495337e-10# 989 3.1587887860951014e-10# 990 3.1248248433257686e-10# 991 3.1373303954751464e-10# 992 3.1042191039887257e-10# 993 3.0178171073202975e-10# 994 3.0526337013725424e-10# 995 2.9184832328610355e-10# 996 2.9478997021215037e-10# 997 2.864908310584724e-10# 998 2.8178703814774053e-10# 999 2.765574436125462e-10# w= 2.0000112056732178# b= 2.0000112056732178# y_pred= tensor([8.0000]) 1.PyTorch Tutorial - P5 Linear Regression with PyTorch ↩","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://hexuanweng.github.io/categories/Data-Science/"}],"tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"http://hexuanweng.github.io/tags/PyTorch/"}]},{"title":"LC433 - Minimum Genetic Mutation","slug":"LC433MinimumGeneticMutation","date":"2022-07-24T07:39:18.000Z","updated":"2022-07-24T07:39:18.000Z","comments":true,"path":"2022/07/24/LC433MinimumGeneticMutation/","permalink":"http://hexuanweng.github.io/2022/07/24/LC433MinimumGeneticMutation/","excerpt":"","text":"DescriptionA gene string can be represented by an 8-character long string, with choices from ‘A’, ‘C’, ‘G’, and ‘T’.Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.For example, “AACCGGTT” –&gt; “AACCGGTA” is one mutation.There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.Given the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.Note that the starting point is assumed to be valid, so it might not be included in the bank. Example 1: 12Input: start = &quot;AACCGGTT&quot;, end = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]Output: 1 Example 2: 12Input: start = &quot;AACCGGTT&quot;, end = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]Output: 2 Example 3: 12Input: start = &quot;AAAAACCC&quot;, end = &quot;AACCCCCC&quot;, bank = [&quot;AAAACCCC&quot;,&quot;AAACCCCC&quot;,&quot;AACCCCCC&quot;]Output: 3 Constraints: 12345start.length == 8end.length == 80 &lt;= bank.length &lt;= 10bank[i].length == 8start, end, and bank[i] consist of only the characters [&#x27;A&#x27;, &#x27;C&#x27;, &#x27;G&#x27;, &#x27;T&#x27;]. SolutionThis question is very similar to [127]If end is not in the bank, return -1 directly Store start in the queue, because there are only four letters of ACGT, so traverse the gene sequence and change one of the letters. If the changed letter is not in visited, put it in the queue If the changed letter is equal to the value of end, return to step If no matching gene is found, return -1 1234567891011121314151617181920# O(nm) time | O(nm) spacefrom collections import dequeclass Solution: def minMutation(self, start: str, end: str, bank: List[str]) -&gt; int: if end not in bank: return -1 queue = deque([(start,0)]) visited = set(&#123;start&#125;) while queue: cur, step = queue.popleft() if cur == end: return step for i in range(8): for j in [&quot;A&quot;,&quot;C&quot;,&quot;G&quot;, &quot;T&quot;]: nxt = cur[:i]+j+cur[i+1:] if nxt in bank and nxt not in visited: queue.append((nxt, step+1)) visited.add(nxt) return -1 1.433. Minimum Genetic Mutation ↩2.127. Word Ladder ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"LC2049 - Count Nodes With the Highest Score","slug":"LC2049CountNodesWiththeHighestScore","date":"2022-07-22T04:36:21.000Z","updated":"2022-07-22T04:36:21.000Z","comments":true,"path":"2022/07/22/LC2049CountNodesWiththeHighestScore/","permalink":"http://hexuanweng.github.io/2022/07/22/LC2049CountNodesWiththeHighestScore/","excerpt":"","text":"DescriptionThere is a binary tree rooted at 0 consisting of n nodes. The nodes are labeled from 0 to n - 1. You are given a 0-indexed integer array parents representing the tree, where parents[i] is the parent of node i. Since node 0 is the root, parents[0] &#x3D;&#x3D; -1.Each node has a score. To find the score of a node, consider if the node and the edges connected to it were removed. The tree would become one or more non-empty subtrees. The size of a subtree is the number of the nodes in it. The score of the node is the product of the sizes of all those subtrees.Return the number of nodes that have the highest score. Example 1: 123456789Input: parents = [-1,2,0,2,0]Output: 3Explanation:- The score of node 0 is: 3 * 1 = 3- The score of node 1 is: 4 = 4- The score of node 2 is: 1 * 1 * 2 = 2- The score of node 3 is: 4 = 4- The score of node 4 is: 4 = 4The highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score. Example 2: 1234567Input: parents = [-1,2,0]Output: 2Explanation:- The score of node 0 is: 2 = 2- The score of node 1 is: 2 = 2- The score of node 2 is: 1 * 1 = 1The highest score is 2, and two nodes (node 0 and node 1) have the highest score. Constraints:n &#x3D;&#x3D; parents.length2 &lt;&#x3D; n &lt;&#x3D; 105parents[0] &#x3D;&#x3D; -10 &lt;&#x3D; parents[i] &lt;&#x3D; n - 1 for i !&#x3D; 0parents represents a valid binary tree. Solutions Store the number of in-degree nodes for each node in degree Store the parent node and child node of the current node in two hash tables respectively The final answer is the product of the number of remaining nodes of the parent node to be deleted and the number of nodes of the self node. 1234567891011121314151617181920212223242526272829303132333435363738394041from collections import dequeclass Solution: def countHighestScoreNodes(self, parents: List[int]) -&gt; int: n = len(parents) degree = [0]*n fathers = defaultdict(list) total = [1]*n children = defaultdict(list) for i, v in enumerate(parents[1:],1): fathers[i].append(v) children[v].append(i) degree[v] += 1 queue = deque() for i in range(n): if degree[i] == 0: queue.append(i) while queue: cur = queue.popleft() for root in fathers[cur]: total[root] += total[cur] degree[root]-=1 if degree[root] == 0: queue.append(root) maxi, ans = 0, 0 for i in range(n): cur = 1 for c in children[i]: cur*=total[c] if i != 0: cur*=(total[0] - total[i]) if cur &gt; maxi: maxi = cur ans = 1 elif cur == maxi: ans +=1 return ans 1.2049. Count Nodes With the Highest Score ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Topological Sorting","slug":"Topological-Sorting","permalink":"http://hexuanweng.github.io/tags/Topological-Sorting/"}]},{"title":"LC851 - Loud and Rich","slug":"LC851LoudAndRich","date":"2022-07-21T08:07:33.000Z","updated":"2022-07-21T08:07:33.000Z","comments":true,"path":"2022/07/21/LC851LoudAndRich/","permalink":"http://hexuanweng.github.io/2022/07/21/LC851LoudAndRich/","excerpt":"","text":"DescriptionThere is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.You are given an array richer where richer[i] &#x3D; [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).Return an integer array answer where answer[x] &#x3D; y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x. Example 1: 123456789Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]Output: [5,5,2,5,4,5,6,7]Explanation: answer[0] = 5.Person 5 has more money than 3, which has more money than 1, which has more money than 0.The only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.answer[7] = 7.Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.The other answers can be filled out with similar reasoning. Example 2: 12Input: richer = [], quiet = [0]Output: [0] Constraints:n &#x3D;&#x3D; quiet.length1 &lt;&#x3D; n &lt;&#x3D; 5000 &lt;&#x3D; quiet[i] &lt; nAll the values of quiet are unique.0 &lt;&#x3D; richer.length &lt;&#x3D; n * (n - 1) &#x2F; 20 &lt;&#x3D; ai, bi &lt; nai !&#x3D; biAll the pairs of richer are unique.The observations in richer are all logically consistent. Solution Draw the graph as required Create a mapping table 【connect】: key: the vertex of the in-degree value: which elements will this vertex of the in-degree point to Create an in-degree table 【degree】 ： key: the value of the vertex; value: how many in-degree elements there are, for example, vertex 3 has 3 in-degree elements (if the vertex is an index, we only need to create an array&#x2F;list) Find the key&#x2F;index that are 0 in the in-degree table, that is, 2, 3, 5, 6, and put these values in the queue Compare the quiet value of the current popleft value and the quiet value of the outdegree element, and update the element 12345678910111213141516171819202122232425262728# O(n+m) time | O(n+m) spacefrom collections import dequeclass Solution: def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -&gt; List[int]: n = len(quiet) connect = defaultdict(list) degree = [0]*n queue = deque() for cur, nxt in richer: connect[cur].append(nxt) degree[nxt] +=1 for i in range(n): if degree[i] == 0: queue.append(i) ans = [i for i in range(n)] while queue: cur = queue.popleft() for nxt in connect[cur]: degree[nxt]-=1 if degree[nxt] == 0: queue.append(nxt) if quiet[ans[cur]] &lt; quiet[ans[nxt]]: ans[nxt] = ans[cur] return ans 1.851. Loud and Rich ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Topological Sorting","slug":"Topological-Sorting","permalink":"http://hexuanweng.github.io/tags/Topological-Sorting/"}]},{"title":"LC210 - Course Schedule II","slug":"LC210CourseScheduleII","date":"2022-07-21T03:01:09.000Z","updated":"2022-07-21T03:01:09.000Z","comments":true,"path":"2022/07/21/LC210CourseScheduleII/","permalink":"http://hexuanweng.github.io/2022/07/21/LC210CourseScheduleII/","excerpt":"","text":"DescriptionThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] &#x3D; [ai, bi] indicates that you must take course bi first if you want to take course ai.For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array. Example 1: 123Input: numCourses = 2, prerequisites = [[1,0]]Output: [0,1]Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]. Example 2: 1234Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]Output: [0,2,1,3]Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3]. Example 3: 12Input: numCourses = 1, prerequisites = []Output: [0] Constraints:1 &lt;&#x3D; numCourses &lt;&#x3D; 20000 &lt;&#x3D; prerequisites.length &lt;&#x3D; numCourses * (numCourses - 1)prerequisites[i].length &#x3D;&#x3D; 20 &lt;&#x3D; ai, bi &lt; numCoursesai !&#x3D; biAll the pairs [ai, bi] are distinct. Solution Prerequesite is stored in courses: [following courses] The number of pre-courses required for each course is stored in pre_nums Traverse pre_nums, if the number of pre-courses of the current course is 0, append the course to the queue After processing all pre_nums[nxt], enqueue all courses with an in-degree of 0 (meaning subjects without pre-course requirements), and run topological sorting. If the length ans of the sorted courses is equal to numCourses, return ans, otherwise return []. 123456789101112131415161718192021222324#O(n+m) time | O(n+m) spacefrom collections import dequeclass Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]: courses = defaultdict(list) pre_nums = [0] * numCourses queue = deque([]) for cur, pre in prerequisites: courses[pre].append(cur) pre_nums[cur] +=1 for i in range(numCourses): if pre_nums[i] == 0: queue.append(i) ans = [] while queue: cur = queue.popleft() ans.append(cur) for nxt in courses[cur]: pre_nums[nxt] -=1 if pre_nums[nxt] == 0: queue.append(nxt) return ans if len(ans) == numCourses else [] 1.207. Course Schedule ↩2.210. Course Schedule II ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Topological Sorting","slug":"Topological-Sorting","permalink":"http://hexuanweng.github.io/tags/Topological-Sorting/"}]},{"title":"LC207 - Course Schedule","slug":"LC207CourseSchedule","date":"2022-07-21T02:44:32.000Z","updated":"2022-07-21T02:44:32.000Z","comments":true,"path":"2022/07/21/LC207CourseSchedule/","permalink":"http://hexuanweng.github.io/2022/07/21/LC207CourseSchedule/","excerpt":"","text":"DescriptionThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] &#x3D; [ai, bi] indicates that you must take course bi first if you want to take course ai.For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.Return true if you can finish all courses. Otherwise, return false. Example 1: 1234Input: numCourses = 2, prerequisites = [[1,0]]Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2: 1234Input: numCourses = 2, prerequisites = [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Constraints:1 &lt;&#x3D; numCourses &lt;&#x3D; 20000 &lt;&#x3D; prerequisites.length &lt;&#x3D; 5000prerequisites[i].length &#x3D;&#x3D; 20 &lt;&#x3D; ai, bi &lt; numCoursesAll the pairs prerequisites[i] are unique. Solutions Prerequesite is stored in courses: [following courses] The number of pre-courses required for each course is stored in pre_nums Traverse pre_nums, if the number of pre-courses of the current course is 0, append the course to the queue When all pre_nums[nxt] are processed, enter all courses with an entry degree of 0 (meaning subjects without pre-course requirements) into the queue, and run the “topological sort” once, if all the number of prerequisite courses equals 0, stating that all courses can be completed. 123456789101112131415161718192021222324# O(m+n) time | O(m+n) spacefrom collections import dequeclass Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool: courses = defaultdict(list) pre_nums = [0] * numCourses queue = deque([]) for cur, pre in prerequisites: courses[pre].append(cur) pre_nums[cur] += 1 for i in range(numCourses): if pre_nums[i] == 0: queue.append(i) while queue: cur = queue.popleft() for nxt in courses[cur]: pre_nums[nxt] -= 1 if pre_nums[nxt] == 0: queue.append(nxt) return True if pre_nums == [0]*numCourses else False 1.207. Course Schedule ↩2.210. Course Schedule II ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Topological Sorting","slug":"Topological-Sorting","permalink":"http://hexuanweng.github.io/tags/Topological-Sorting/"}]},{"title":"LC814 - Binary Tree Prunting","slug":"LC814BinaryTreePrunting","date":"2022-07-21T01:47:46.000Z","updated":"2022-07-21T01:47:46.000Z","comments":true,"path":"2022/07/21/LC814BinaryTreePrunting/","permalink":"http://hexuanweng.github.io/2022/07/21/LC814BinaryTreePrunting/","excerpt":"","text":"DescriptionGiven the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.A subtree of a node node is node plus every node that is a descendant of node. Example 1: 12345Input: root = [1,null,0,0,1]Output: [1,null,0,null,1]Explanation: Only the red nodes satisfy the property &quot;every subtree not containing a 1&quot;.The diagram on the right represents the answer. Example 2: 12Input: root = [1,0,1,0,0,0,1]Output: [1,null,1,null,1] Example 3: 12Input: root = [1,1,0,1,1,0,1,0]Output: [1,1,0,1,1,null,1] Constraints:The number of nodes in the tree is in the range [1, 200].Node.val is either 0 or 1. SolutionsThis is a post-order traversal If the following conditions are met, delete the current leaf node Left subtree is None The right subtree is None The current root value is 0 123456789101112131415161718# O(n) time | O(n) space# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def pruneTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]: if root is None: return root.left = self.pruneTree(root.left) root.right = self.pruneTree(root.right) if root.left is None and root.right is None and root.val == 0: return return root 1.814. Binary Tree Pruning ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Recursion","slug":"Recursion","permalink":"http://hexuanweng.github.io/tags/Recursion/"},{"name":"Depth First Search","slug":"Depth-First-Search","permalink":"http://hexuanweng.github.io/tags/Depth-First-Search/"}]},{"title":"LC1260 - Shift 2D Grid","slug":"LC1260Shift2DGrid","date":"2022-07-20T05:07:53.000Z","updated":"2022-07-20T05:07:53.000Z","comments":true,"path":"2022/07/20/LC1260Shift2DGrid/","permalink":"http://hexuanweng.github.io/2022/07/20/LC1260Shift2DGrid/","excerpt":"","text":"DescriptionGiven a 2D grid of size m x n and an integer k. You need to shift the grid k times.In one shift operation:Element at grid[i][j] moves to grid[i][j + 1].Element at grid[i][n - 1] moves to grid[i + 1][0].Element at grid[m - 1][n - 1] moves to grid[0][0].Return the 2D grid after applying shift operation k times. Example 1: 12Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1Output: [[9,1,2],[3,4,5],[6,7,8]] Example 2: 12Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Example 3: 12Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9Output: [[1,2,3],[4,5,6],[7,8,9]] Constraints:m &#x3D;&#x3D; grid.lengthn &#x3D;&#x3D; grid[i].length1 &lt;&#x3D; m &lt;&#x3D; 501 &lt;&#x3D; n &lt;&#x3D; 50-1000 &lt;&#x3D; grid[i][j] &lt;&#x3D; 10000 &lt;&#x3D; k &lt;&#x3D; 100 Solutions Flatten to a one-dimensional list with k step: vector Convert to two-dimensional according to the number of rows and columns: metrix123456789101112131415161718192021# O(nm) time | O(nm) spaceclass Solution: def shiftGrid(self, grid: List[List[int]], k: int) -&gt; List[List[int]]: m, n = len(grid), len(grid[0]) vector = [0] * m*n cur_idx = 0 for r in range(m): for c in range(n): idx = (cur_idx+k)% (m*n) vector[idx] = grid[r][c] cur_idx+=1 idx = 0 ans = [] for r in range(m): level = [] for c in range(n): level.append(vector[idx]) idx+=1 ans.append(level) return ans Optimize space complexity 12345678910111213# O(nm) time | O(1) spaceclass Solution: def shiftGrid(self, grid: List[List[int]], k: int) -&gt; List[List[int]]: m, n = len(grid), len(grid[0]) matrix = [[0] * n for _ in range(m)] cur_idx = 0 for r in range(m): for c in range(n): idx = (cur_idx+k)% (m*n) matrix[idx//n][idx%n] = grid[r][c] cur_idx+=1 return matrix 1.1260. Shift 2D Grid ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Simulation","slug":"Simulation","permalink":"http://hexuanweng.github.io/tags/Simulation/"}]},{"title":"LC1034 - Coloring a Border","slug":"LC1034ColoringABorder","date":"2022-07-20T03:43:13.000Z","updated":"2022-07-20T03:43:13.000Z","comments":true,"path":"2022/07/20/LC1034ColoringABorder/","permalink":"http://hexuanweng.github.io/2022/07/20/LC1034ColoringABorder/","excerpt":"","text":"DescriptionYou are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location.Two squares belong to the same connected component if they have the same color and are next to each other in any of the 4 directions.The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).You should color the border of the connected component that contains the square grid[row][col] with color.Return the final grid. Example 1:Input: grid &#x3D; [[1,1],[1,2]], row &#x3D; 0, col &#x3D; 0, color &#x3D; 3Output: [[3,3],[3,2]] Example 2:Input: grid &#x3D; [[1,2,2],[2,3,2]], row &#x3D; 0, col &#x3D; 1, color &#x3D; 3Output: [[1,3,3],[2,3,3]] Example 3:Input: grid &#x3D; [[1,1,1],[1,1,1],[1,1,1]], row &#x3D; 1, col &#x3D; 1, color &#x3D; 2Output: [[2,2,2],[2,1,2],[2,2,2]] Constraints:m &#x3D;&#x3D; grid.lengthn &#x3D;&#x3D; grid[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 501 &lt;&#x3D; grid[i][j], color &lt;&#x3D; 10000 &lt;&#x3D; row &lt; m0 &lt;&#x3D; col &lt; n SolutionsHow to define connected component boundaries? The color is the same as grid[row][col] and connected to the connected component. These two conditions must be met When a point that satisfies the above conditions appears in the outermost circle, it must be a boundary. When a point that meets the above conditions appears in the inner circle, if there is a point around it with a different color than grid[row][col], it is the boundary. So… we should find out all the connected components and set the value to -1 then we should found all the boundaries and add them to a set. convert components equal to -1 to color if they are in boundaries, otherwise, convert them back to the original color. 12345678910111213141516171819202122232425262728293031323334from collections import dequeclass Solution: def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -&gt; List[List[int]]: m, n = len(grid), len(grid[0]) queue = deque([(row, col)]) ori = grid[row][col] grid[row][col] = -1 while queue: r, c = queue.popleft() for dx, dy in [(1,0),(0,1),(-1,0),(0,-1)]: nx, ny = r+dx, c+dy if 0&lt;=nx&lt;m and 0&lt;=ny&lt;n and grid[nx][ny] == ori: grid[nx][ny] = -1 queue.append((nx,ny)) # find boarders edge = set() for r in range(m): for c in range(n): for dx, dy in [(1,0),(0,1),(-1,0),(0,-1)]: nx, ny = r+dx, c+dy if nx &lt; 0 or nx &gt;= m or ny &lt;0 or ny &gt;= n or grid[nx][ny] != -1: edge.add((r, c)) break # color the item in edge and revert the other -1 back to original color for r in range(m): for c in range(n): if grid[r][c] == -1: if (r,c) in edge: grid[r][c] = color else: grid[r][c] = ori return grid 1.1034. Coloring A Border ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"LC909 - Snakes and Ladders","slug":"LC909SnakesandLadders","date":"2022-07-20T01:50:57.000Z","updated":"2022-07-20T01:50:57.000Z","comments":true,"path":"2022/07/20/LC909SnakesandLadders/","permalink":"http://hexuanweng.github.io/2022/07/20/LC909SnakesandLadders/","excerpt":"","text":"DescriptionYou are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.You start on square 1 of the board. In each move, starting from square curr, do the following:Choose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.If next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.The game ends when you reach the square n2.A board square on row r and column c has a snake or ladder if board[r][c] !&#x3D; -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 do not have a snake or ladder.Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.For example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.Return the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1. Example 1: 123456789Input: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]Output: 4Explanation: In the beginning, you start at square 1 (at row 5, column 0).You decide to move to square 2 and must take the ladder to square 15.You then decide to move to square 17 and must take the snake to square 13.You then decide to move to square 14 and must take the ladder to square 35.You then decide to move to square 36, ending the game.This is the lowest possible number of moves to reach the last square, so return 4. Example 2: 12Input: board = [[-1,-1],[-1,3]]Output: 1 Constraints: n &#x3D;&#x3D; board.length &#x3D;&#x3D; board[i].length2 &lt;&#x3D; n &lt;&#x3D; 20grid[i][j] is either -1 or in the range [1, n2].The squares labeled 1 and n2 do not have any ladders or snakes. Solutions first, we use a hashtable to store all the snakers and ladders. This can convert the 2-dimensional problem to 1-dimensional problem Using breadth search to find the shortest path, we need to maintain such a queue queue &#x3D; [(1, 0)], the first element represents the position reached, the second element represents the number of steps required to reach the position, and then pops the first step of the queue For point i, add all unvisited points with step i+1 at the end of the queue. 12345678910111213141516171819202122232425262728293031323334353637383940from collections import dequeclass Solution: def snakesAndLadders(self, board: List[List[int]]) -&gt; int: n = len(board) graph = &#123;&#125; cur_idx = 0 is_odd = False for i in reversed(range(n)): for j in reversed(range(n)) if is_odd else range(n): cur_idx +=1 if board[i][j] != -1: graph[cur_idx] = board[i][j] is_odd = not is_odd #BFS queue = deque([(1, 0)]) visited = set() maxi = 0 while queue: cur, step = queue.popleft() for i in range(1, 7): nxt = cur+i if nxt &gt; n*n: break if nxt in graph: nxt = graph[nxt] if nxt not in visited: visited.add(nxt) queue.append((nxt, step+1)) else: if nxt not in visited: visited.add(nxt) maxi = nxt if nxt == n*n: return step+1 if maxi: queue.append((maxi, step+1)) return -1 1.909. Snakes and Ladders ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"LC815 - Bus Routes","slug":"LC815BusRoutes","date":"2022-07-18T01:43:56.000Z","updated":"2022-07-18T01:43:56.000Z","comments":true,"path":"2022/07/18/LC815BusRoutes/","permalink":"http://hexuanweng.github.io/2022/07/18/LC815BusRoutes/","excerpt":"","text":"DescriptionYou are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.For example, if routes[0] &#x3D; [1, 5, 7], this means that the 0th bus travels in the sequence 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; … forever.You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible. Example 1:Input: routes &#x3D; [[1,2,7],[3,6,7]], source &#x3D; 1, target &#x3D; 6Output: 2Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6. Example 2:Input: routes &#x3D; [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source &#x3D; 15, target &#x3D; 12Output: -1Constraints:1 &lt;&#x3D; routes.length &lt;&#x3D; 500.1 &lt;&#x3D; routes[i].length &lt;&#x3D; 105All the values of routes[i] are unique.sum(routes[i].length) &lt;&#x3D; 1050 &lt;&#x3D; routes[i][j] &lt; 1060 &lt;&#x3D; source, target &lt; 106 Solution HashSet + BFS we consider the index of the routes as the bus number, for each bus, we have several stops we store the stops as the key, and the bus number as the value into the stops_hash. We also make each bus’ stops into a set as bus_set for the stops in one bus, we don’t need to worry about how many buses we need to transit. Therefore, we append the unvisited stops into the bus and the step +1. In this case, all the stops in one bus will have the same steps. when the current stop equals target, we return steps. 1234567891011121314151617181920212223242526272829from collections import dequeclass Solution: def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -&gt; int: stops_hash = &#123;&#125; buses_set = [] for idx, value in enumerate(routes): buses_set.append(set(value)) for v in value: if v not in stops_hash: stops_hash[v] = set(&#123;idx&#125;) else: stops_hash[v].add(idx) # &#123;1: &#123;0&#125;, 2: &#123;0&#125;, 7: &#123;0, 1&#125;, 3: &#123;1&#125;, 6: &#123;1&#125;&#125; # [&#123;1, 2, 7&#125;, &#123;3, 6, 7&#125;] queue = deque([(source, 0)]) bus_visited = set() stop_visited = set(&#123;source&#125;) while queue: cur_stop, step = queue.popleft() if cur_stop == target: return step for bus in stops_hash[cur_stop] - bus_visited: for stop in buses_set[bus] - stop_visited: bus_visited.add(bus) stop_visited.add(stop) queue.append((stop, step+1)) return -1 1.815. Bus Routes ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"hard","slug":"hard","permalink":"http://hexuanweng.github.io/tags/hard/"},{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"}]},{"title":"LC565 - Array Nesting","slug":"LC565ArrayNesting","date":"2022-07-17T10:23:32.000Z","updated":"2022-07-17T10:23:32.000Z","comments":true,"path":"2022/07/17/LC565ArrayNesting/","permalink":"http://hexuanweng.github.io/2022/07/17/LC565ArrayNesting/","excerpt":"","text":"DescriptionYou are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].You should build a set s[k] &#x3D; {nums[k], nums[nums[k]], nums[nums[nums[k]]], … } subjected to the following rule:The first element in s[k] starts with the selection of the element nums[k] of index &#x3D; k.The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.We stop adding right before a duplicate element occurs in s[k].Return the longest length of a set s[k]. Example 1:Input: nums &#x3D; [5,4,0,3,1,6,2]Output: 4Explanation:nums[0] &#x3D; 5, nums[1] &#x3D; 4, nums[2] &#x3D; 0, nums[3] &#x3D; 3, nums[4] &#x3D; 1, nums[5] &#x3D; 6, nums[6] &#x3D; 2.One of the longest sets s[k]:s[0] &#x3D; {nums[0], nums[5], nums[6], nums[2]} &#x3D; {5, 6, 2, 0} Example 2:Input: nums &#x3D; [0,1,2]Output: 1Constraints:1 &lt;&#x3D; nums.length &lt;&#x3D; 1050 &lt;&#x3D; nums[i] &lt; nums.lengthAll the values of nums are unique. SolutionYou can simulate directly according to the meaning of the question. traverse each nums[i] from front to back in order to prevent some rings from being repeated Processing, for the current passing nums[i] is marked as −1, so that each number is accessed no more than 3 times, and the overall complexity is O(n).1234567891011121314151617# O(n) time | O(1) spaceclass Solution: def arrayNesting(self, nums: List[int]) -&gt; int: n = len(nums) ans = 0 for i, v in enumerate(nums): if v == -1: continue c, cur = i, v cnt = 0 while cur != -1: nums[c] = -1 c, cur = cur, nums[cur] cnt +=1 ans = max(ans, cnt) return ans 1.565. Array Nesting ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Simulation","slug":"Simulation","permalink":"http://hexuanweng.github.io/tags/Simulation/"}]},{"title":"LC - Weekly Contest 302","slug":"LC-WeeklyContest302","date":"2022-07-17T07:36:21.000Z","updated":"2022-07-17T07:36:21.000Z","comments":true,"path":"2022/07/17/LC-WeeklyContest302/","permalink":"http://hexuanweng.github.io/2022/07/17/LC-WeeklyContest302/","excerpt":"","text":"2341. Maximum Number of Pairs in Array Store the nums value as the key, the frequency of each num as value 1234567891011121314151617# O(n) time | O(n) spaceclass Solution: def numberOfPairs(self, nums: List[int]) -&gt; List[int]: h = &#123;&#125; for num in nums: if num not in h: h[num] = 1 else: h[num] +=1 cnt0 = 0 cnt1 = 0 for k, v in h.items(): temp0, temp1 = divmod(v, 2) cnt0+= temp0 cnt1+= temp1 return [cnt0, cnt1] 2342. Max Sum of a Pair With Equal Sum of Digits Store the sum of each digit in each num as the key, and store the values of the corresponding nums as the value make the value sorted 12345678910111213141516171819202122232425# O(n) time | O(n) spacefrom sortedcontainers import SortedListclass Solution: def maximumSum(self, nums: List[int]) -&gt; int: h = &#123;&#125; for num in nums: s = 0 temp = num while temp: s += temp % 10 temp//=10 if s not in h: h[s] = SortedList([num]) else: h[s].add(num) maxi = -1 for k, v in h.items(): if len(v) &lt;2: continue maxi = max(maxi, v[-1]+v[-2]) return maxi 2343. Query Kth Smallest Trimmed Number Trim the string based on the trim store the index and result into arr sort arr get the kth smallest trimmed number 1234567891011# O(nm) time | O(n) spaceclass Solution: def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -&gt; List[int]: ans=[] for k,trim in queries: arr=[] for i,v in enumerate(nums): arr.append((v[-trim:],i)) arr.sort() ans.append(arr[k-1][1]) return ans 2344. Minimum Deletions to Make Array Divisible use math.gcd to get the greatest common divisor of the list sort the numbers list travers numbers list and when the common divisor can divides the current number without a reminder, which means the current index is the number of deleted times 123456789101112# O(nlogn) time | O(1) spaceclass Solution: def minOperations(self, nums: List[int], numsDivide: List[int]) -&gt; int: cur = numsDivide[0] for i in numsDivide[1:]: cur = math.gcd(cur, i) nums.sort() for i, v in enumerate(nums): if cur%v == 0: return i return -1 NoteThe math.gcd() method returns the greatest common divisor of the two integers int1 and int2. GCD is the largest common divisor that divides the numbers without a remainder. GCD is also known as the highest common factor (HCF). Tip: gcd(0,0) returns 0. 123math.gcd(int1, int2)# return An int value, representing the greatest common divisor (GCD) for two integers 1.2341. Maximum Number of Pairs in Array ↩2.2342. Max Sum of a Pair With Equal Sum of Digits ↩3.2343. Query Kth Smallest Trimmed Number ↩4.2344. Minimum Deletions to Make Array Divisible ↩5.Python math.gcd() Method ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"http://hexuanweng.github.io/tags/Weekly-Contest/"}]},{"title":"PyTorch Tutorial - Backpropagation","slug":"PyTorch-P4","date":"2022-07-14T12:48:32.000Z","updated":"2022-07-14T12:48:32.000Z","comments":true,"path":"2022/07/14/PyTorch-P4/","permalink":"http://hexuanweng.github.io/2022/07/14/PyTorch-P4/","excerpt":"","text":"Tensor12345678910111213import torcha = torch.tensor([1.0])a.requires_grad = Trueprint(a) #tensor([1.], requires_grad=True)print(a.data) #tensor([1.])print(a.type()) #torch.FloatTensorprint(a.data.type()) #torch.FloatTensorprint(a.grad) #Noneprint(type(a.grad)) print(a.item()) # 1.0print(type(a.item())) #&lt;class &#x27;float&#x27;&gt; Backpropagation123456789101112131415161718192021222324252627282930313233343536373839404142434445import torchimport matplotlib.pyplot as plt# prepare the training datax_data = [1.0, 2.0, 3.0]y_data = [2.0, 4.0, 6.0]# initialize weightsw = torch.tensor([1.0])w.requires_grad = True # need to calculate the gradient # define a linear modeldef forward(x): return w*x # this is a tensor# define a loss functiondef loss(x, y): y_pred = forward(x) return (y_pred-y)**2# training processepoch_list = []loss_list = []print(&quot;prediction (before training):&quot;, 4, forward(4).item())for epoch in range(100): for x, y in zip(x_data, y_data): l = loss(x, y) # l is a tensor. Tensor is to build computational graph l.backward() # backward, compute grad for Tensor whose requires_grad == True # in the previous lecture: grad = 2*x*(x*w-y) print(&quot;\\tgrad: &quot;, x, y, w.grad.item()) w.data -= 0.01*w.grad.data # update the tensor, grad is a tensor here w.grad.data.zero_()# set the grad to zero print(&quot;progress: &quot;, epoch, l.item()) epoch_list.append(epoch) loss_list.append(l.item())print(&quot;predict (after training): &quot;, 4, forward(4).item())# visualizationplt.plot(epoch_list, loss_list)plt.ylabel(&quot;loss&quot;)plt.xlabel(&quot;epoch&quot;)plt.show() ExerciseExercise 4-1: Calculate the partial derivative of the loss with respect to the weight Exercise 4-2: Calculate the partial derivative of the loss with respect to the weight AssignmentExercise 4-3: Calculate the partial derivative of the loss with respect to the weight PyTorch Implementation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import numpy as npimport matplotlib.pyplot as pltimport torch# prepare training datax_data = [1.0, 2.0, 3.0]y_data = [2.0, 4.0, 6.0]# initialize w1, w2, bw1 = torch.Tensor([1.0])w1.requires_grad = Truew2 = torch.Tensor([1.0])w2.requires_grad = Trueb = torch.Tensor([1.0])b.requires_grad = True# define linear modeldef forward(x): return w1*x**2 + w2*x+b# define loss function -&gt; build up the computational graphdef loss(x, y): y_pred = forward(x) return (y_pred - y) **2## training processepoch_list = []loss_list = []print(&#x27;Predict (before training):&#x27;, 4, forward(4))for epoch in range(100): for x,y in zip(x_data, y_data): l = loss(x, y) l.backward() print(&quot;\\tgradient: &quot;, x, y, w1.grad.item(), w2.grad.item(), b.grad.item()) w1.data -= 0.01 * w1.grad.data w2.data -= 0.01 * w2.grad.data b.data -= 0.01 * b.grad.data # set tensor to zero w1.grad.data.zero_() w2.grad.data.zero_() b.grad.data.zero_() print(&#x27;Epoch: &#x27;, epoch, l.item()) epoch_list.append(epoch) loss_list.append(l.item())print(&quot;Predoct (after training):&quot;, 4, forward(4).item())# visualizationplt.plot(epoch_list, loss_list)plt.ylabel(&quot;loss&quot;)plt.xlabel(&quot;epoch&quot;)plt.show() 1.PyTorch Tutorial - P4 Backpropagation ↩","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://hexuanweng.github.io/categories/Data-Science/"}],"tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"http://hexuanweng.github.io/tags/PyTorch/"}]},{"title":"PyTorch Tutorial - Gradient Descent","slug":"PyTorch-P3","date":"2022-07-14T12:04:41.000Z","updated":"2022-07-14T12:04:41.000Z","comments":true,"path":"2022/07/14/PyTorch-P3/","permalink":"http://hexuanweng.github.io/2022/07/14/PyTorch-P3/","excerpt":"","text":"Gradient Descent123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import matplotlib.pyplot as plt# prepare the training datax_data = [1.0, 2.0, 3.0]y_data = [2.0, 4.0, 6.0]# initialize guess of weightw = 1.0# define the linear modeldef forward(x): return w*x# cost functiondef cost(xs, ys): cost = 0 for x, y in zip(xs, ys): y_pred = forward(x) cost += (y_pred - y) **2 return cost/len(xs)# define the gradientdef gradient(xs, ys): grad = 0 for x, y in zip(xs, ys): grad += 2*x*(x*w-y) return grad/len(xs)# training processepoch_list = []cost_list = []print(&#x27;predict (before training):&#x27;, 4, forward(4))for epoch in range(100): cost_val = cost(x_data, y_data) grad_val = gradient(x_data, y_data) w -= 0.01 * grad_val print(&#x27;epoch:&#x27;, epoch, &quot;w=&quot;, w, &#x27;loss:&#x27;, cost_val) epoch_list.append(epoch) cost_list.append(cost_val)print(&#x27;predict (after training):&#x27;, 4, forward(4))#visualizationplt.plot(epoch_list, cost_list)plt.ylabel(&quot;cost&quot;)plt.xlabel(&quot;epoch&quot;)plt.show() Stochastic Gradient Descent12345678910111213141516171819202122232425262728293031323334353637383940414243import matplotlib.pyplot as plt# prepare the training datasetx_data = [1.0, 2.0, 3.0]y_data = [2.0, 3.0, 4.0]# initialize ww = 1.0# define the linear modeldef forward(x): return w*x # define the loss functiondef loss(x, y): y_pred = forward(x) return (y_pred - y) **2# define the stochastic gradient descent functiondef gradient(x, y): return 2*x*(x*w-y)# training process epoch_list = []loss_list = []print(&#x27;predict (before training):&#x27;, 4, forward(4))for epoch in range(100): for x, y in zip(x_data, y_data): l = loss(x, y) grad = gradient(x, y) w -= 0.01 * grad print(&quot;\\tgradient:&quot;, x, y, grad) print(&quot;process: &quot;, epoch, &quot;w=&quot;, w, &quot;loss=&quot;, l) epoch_list.append(epoch) loss_list.append(l)print(&quot;predict (after training)&quot;, 4, forward(4))# visualizationplt.plot(epoch_list, loss_list)plt.ylabel(&quot;loss&quot;)plt.xlabel(&quot;epoch&quot;)plt.show() 1.PyTorch Tutorial - P3 Gradient Descent ↩","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://hexuanweng.github.io/categories/Data-Science/"}],"tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"http://hexuanweng.github.io/tags/PyTorch/"}]},{"title":"LC735 - Asteroid Collision","slug":"LC735AsteroidCollision","date":"2022-07-13T12:22:36.000Z","updated":"2022-07-13T12:22:36.000Z","comments":true,"path":"2022/07/13/LC735AsteroidCollision/","permalink":"http://hexuanweng.github.io/2022/07/13/LC735AsteroidCollision/","excerpt":"","text":"DescriptionWe are given an array asteroids of integers representing asteroids in a row.For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet. Example 1:Input: asteroids &#x3D; [5,10,-5]Output: [5,10]Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide. Example 2:Input: asteroids &#x3D; [8,-8]Output: []Explanation: The 8 and -8 collide exploding each other. Example 3:Input: asteroids &#x3D; [10,2,-5]Output: [10]Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10. Constraints:2 &lt;&#x3D; asteroids.length &lt;&#x3D; 104-1000 &lt;&#x3D; asteroids[i] &lt;&#x3D; 1000asteroids[i] !&#x3D; 0 SolutionSince collision cancellation always occurs between adjacent planets, we can use “stacks” to simulate this process. Process all the ats[i] from the front to the back, and use the stack to store the planets that are not currently offset. When the direction of the top element of the stack is to the right, and the current ats[i]ats[i] direction is to the left, the offset will occur. Operation, the offset process can be carried out according to the rules. 1234567891011121314# O(n) time | O(n) spaceclass Solution: def asteroidCollision(self, asteroids: List[int]) -&gt; List[int]: ans = [] for star in asteroids: while ans and ans[-1] &gt; 0 and star &lt; 0: pre, cur = ans[-1], -star if pre &lt;= cur: ans.pop() if pre &gt;= cur: break else: ans.append(star) return ans 1.735. Asteroid Collision ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Stack","slug":"Stack","permalink":"http://hexuanweng.github.io/tags/Stack/"}]},{"title":"PyTorch Tutorial - Linear Model","slug":"PyTorch-P2","date":"2022-07-12T11:23:30.000Z","updated":"2022-07-12T11:23:30.000Z","comments":true,"path":"2022/07/12/PyTorch-P2/","permalink":"http://hexuanweng.github.io/2022/07/12/PyTorch-P2/","excerpt":"","text":"Linear Model12345678910111213141516171819202122232425262728293031323334353637383940# 1. import librariesimport numpy as npimport matplotlib.pyplot as plt# 2. Datasetx_data = [1,2,3]y_data = [2,4,6]# 3. Design Modeldef forward(x,w): return x*w# 4. define loss functiondef loss(x, y, y_pred): # y_pred = forward(x) loss = (y_pred - y) **2 return loss# create lists to store weights and mse resultw_list = []mse_list = []# Exhaustive Attack method/Brute Force Method# get MSE under different weightsfor w in np.arange(0.0, 4.1, 0.1): l_sum = 0 for x_val, y_val in zip(x_data, y_data): y_pred_val = forward(x_val, w) loss_val = loss(x_val, y_val, y_pred_val) l_sum += loss_val print(&quot;\\t&quot;, x_val, y_val, y_pred_val, loss_val) print(&quot;MSE=&quot;, l_sum/len(x_data)) w_list.append(w) mse_list.append(l_sum/len(x_data))# visualizationplt.plot(w_list, mse_list)plt.ylabel(&quot;Loss&quot;)plt.xlabel(&#x27;w&#x27;)plt.show() AssignmentTry to use the model: y &#x3D; x*w + b, and draw the cost graph. Tips: You can read the material of how to draw 3d graph. [link] Function np.meshgrid() is very popular for drawing 3d graph, read the [docs] and utilize vectorization calculation. 12345678910111213141516171819202122232425262728293031323334353637import numpy as npimport matplotlib.pyplot as pltx_data = [1,2,3]y_data = [2,4,6]def forward(x,w,b): y = x*w+b return y def loss(y, y_pred): loss = (y_pred-y)**2 return lossw_list = []b_list = []mse_list = []for w in np.arange(0.1, 4.1, 0.1): for b in np.arange(-2.0, 2.1, 0.1): print(&quot;w:&quot;, w, &quot;b:&quot;, b) l_sum = 0 for x_val, y_val in zip(x_data, y_data): y_pred_val = forward(x_val, w, b) loss_val = loss(y_val, y_pred_val) l_sum += loss_val print(&quot;\\t&quot;, x_val, y_val, y_pred_val, loss_val) print(&quot;MSE=&quot;, l_sum/len(x_data)) mse_list.append(l_sum/len(x_data)) w_list.append(w) b_list.append(b)fig = plt.figure()ax = fig.add_subplot(111, projection=&#x27;3d&#x27;)ax.plot3D(w_list, b_list, mse_list)plt.show() 1.PyTorch Tutorial - P2 Linear Model ↩","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://hexuanweng.github.io/categories/Data-Science/"}],"tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"http://hexuanweng.github.io/tags/PyTorch/"}]},{"title":"LC676 - Implement Magic Dictionary","slug":"LC676ImplementMagicDictionary","date":"2022-07-11T05:07:34.000Z","updated":"2022-07-11T05:07:34.000Z","comments":true,"path":"2022/07/11/LC676ImplementMagicDictionary/","permalink":"http://hexuanweng.github.io/2022/07/11/LC676ImplementMagicDictionary/","excerpt":"","text":"DescriptionDesign a data structure that is initialized with a list of different words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure.Implement the MagicDictionary class:MagicDictionary() Initializes the object.void buildDict(String[] dictionary) Sets the data structure with an array of distinct strings dictionary.bool search(String searchWord) Returns true if you can change exactly one character in searchWord to match any string in the data structure, otherwise returns false. Example 1:Input[“MagicDictionary”, “buildDict”, “search”, “search”, “search”, “search”][[], [[“hello”, “leetcode”]], [“hello”], [“hhllo”], [“hell”], [“leetcoded”]]Output[null, null, false, true, false, false]ExplanationMagicDictionary magicDictionary &#x3D; new MagicDictionary();magicDictionary.buildDict([“hello”, “leetcode”]);magicDictionary.search(“hello”); &#x2F;&#x2F; return FalsemagicDictionary.search(“hhllo”); &#x2F;&#x2F; We can change the second ‘h’ to ‘e’ to match “hello” so we return TruemagicDictionary.search(“hell”); &#x2F;&#x2F; return FalsemagicDictionary.search(“leetcoded”); &#x2F;&#x2F; return False Constraints:1 &lt;&#x3D; dictionary.length &lt;&#x3D; 1001 &lt;&#x3D; dictionary[i].length &lt;&#x3D; 100dictionary[i] consists of only lower-case English letters.All the strings in dictionary are distinct.1 &lt;&#x3D; searchWord.length &lt;&#x3D; 100searchWord consists of only lower-case English letters.buildDict will be called only once before search.At most 100 calls will be made to search. Solution All strings in the buildDict(String[] dictionary) method are stored in the hash set Traverse all elements in the set, use double pointers (l, r) and a variable (diff) to determine how many elements in the two strings are different, if diff &#x3D;&#x3D; 1, return True directly, if all elements in the set are compared Returns False if it has not returned True123456789101112131415161718192021222324252627282930class MagicDictionary: def __init__(self): self.dict = set() def buildDict(self, dictionary: List[str]) -&gt; None: for word in dictionary: self.dict.add(word) def search(self, searchWord: str) -&gt; bool: for item in self.dict: if len(item) != len(searchWord) or item == searchWord: continue diff = 0 for i in range(len(item)): if item[i] != searchWord[i]: diff+=1 if diff &gt;1: break if diff == 1: return True return False# Your MagicDictionary object will be instantiated and called as such:# obj = MagicDictionary()# obj.buildDict(dictionary)# param_2 = obj.search(searchWord)#Runtime: 111 ms, faster than 93.47% of Python3 online submissions for Implement Magic Dictionary.#Memory Usage: 14.2 MB, less than 80.94% of Python3 online submissions for Implement Magic Dictionary. 1.676. Implement Magic Dictionary ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Simulation","slug":"Simulation","permalink":"http://hexuanweng.github.io/tags/Simulation/"}]},{"title":"LC127 - Word Ladder","slug":"LC127WordLadder","date":"2022-07-08T01:54:15.000Z","updated":"2022-07-08T01:54:15.000Z","comments":true,"path":"2022/07/08/LC127WordLadder/","permalink":"http://hexuanweng.github.io/2022/07/08/LC127WordLadder/","excerpt":"","text":"DescriptionA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk such that:Every adjacent pair of words differs by a single letter.Every si for 1 &lt;&#x3D; i &lt;&#x3D; k is in wordList. Note that beginWord does not need to be in wordList.sk &#x3D;&#x3D; endWordGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists. Example 1:Input: beginWord &#x3D; “hit”, endWord &#x3D; “cog”, wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]Output: 5Explanation: One shortest transformation sequence is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; cog”, which is 5 words long. Example 2:Input: beginWord &#x3D; “hit”, endWord &#x3D; “cog”, wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”]Output: 0Explanation: The endWord “cog” is not in wordList, therefore there is no valid transformation sequence. Constraints:1 &lt;&#x3D; beginWord.length &lt;&#x3D; 10endWord.length &#x3D;&#x3D; beginWord.length1 &lt;&#x3D; wordList.length &lt;&#x3D; 5000wordList[i].length &#x3D;&#x3D; beginWord.lengthbeginWord, endWord, and wordList[i] consist of lowercase English letters.beginWord !&#x3D; endWordAll the words in wordList are unique. Solution Think of words as nodes, and bring out the adjacent nodes of the next layer from one node, and use BFS to do it. Maintain a queue, let the starting word enter the queue, the level is 1, and then dequeue it for investigation. Turn each character into one of the 26 letters to see if it is in the word list, if so, the new word is the conversion word for the next level. enqueue it, its level +1, and delete the word from the word list. Dequeue, enqueue… Repeat, when the dequeued word is the same as the end word, the end word is encountered, and its level is returned. When the queue is empty, it means that all words have been examined, no end word has been encountered, and there is no path leading to the end. 12345678910111213141516171819# O(N×C^2) time | O(N×C^2) spacefrom collections import dequeclass Solution: def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; int: wordSet = set(wordList) n = len(endWord) queue = deque([(beginWord,1)]) while queue: word, step = queue.popleft() if word == endWord: return step for w in range(len(word)): for i in range(ord(&#x27;a&#x27;), ord(&#x27;z&#x27;)+1): temp = word[:w] + chr(i) + word[w+1:] if temp in wordSet: queue.append((temp, step+1)) wordSet.remove(temp) return 0 1.127. Word Ladder ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"hard","slug":"hard","permalink":"http://hexuanweng.github.io/tags/hard/"},{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"}]},{"title":"LC1217 - Minimum Cost to Move Chips to the Same Position","slug":"LC1217MinimumCosttoMoveChipstoTheSamePosition","date":"2022-07-08T00:50:15.000Z","updated":"2022-07-08T00:50:15.000Z","comments":true,"path":"2022/07/08/LC1217MinimumCosttoMoveChipstoTheSamePosition/","permalink":"http://hexuanweng.github.io/2022/07/08/LC1217MinimumCosttoMoveChipstoTheSamePosition/","excerpt":"","text":"DescriptionWe have n chips, where the position of the ith chip is position[i].We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:position[i] + 2 or position[i] - 2 with cost &#x3D; 0.position[i] + 1 or position[i] - 1 with cost &#x3D; 1.Return the minimum cost needed to move all the chips to the same position. Example 1: Input: position &#x3D; [1,2,3]Output: 1Explanation: First step: Move the chip at position 3 to position 1 with cost &#x3D; 0.Second step: Move the chip at position 2 to position 1 with cost &#x3D; 1.Total cost is 1. Example 2: Input: position &#x3D; [2,2,2,3,3]Output: 2Explanation: We can move the two chips at position 3 to position 2. Each move has cost &#x3D; 1. The total cost &#x3D; 2. Example 3:Input: position &#x3D; [1,1000000000]Output: 1 Constraints:1 &lt;&#x3D; position.length &lt;&#x3D; 1001 &lt;&#x3D; position[i] &lt;&#x3D; 10^9 SolutionThis is a greedy problem, you need to realize that the cost is not related to the specific location, only the parity of the locationThe cost for each chip move is: Move two locations with 0 cost Moving one position has a cost of 1 easy to get: the cost of moving from odd-numbered bits to odd-numbered bits is always 0, and the cost of moving from even-numbered bits to even-numbered bits is always 0. Method1Use a dictionary to store the number of times the coin appears at each position, then iterate over the dictionary and sum the parity separately.Returns the smaller of two odd and even numbers. 1234567891011121314151617# O(n) time | O(n) spaceclass Solution: def minCostToMoveChips(self, position: List[int]) -&gt; int: coins = &#123;&#125; for coin in position: if coin not in coins: coins[coin] = 1 else: coins[coin] +=1 odd, even = 0, 0 for key, val in coins.items(): if key % 2 == 0: even += val else: odd += val return min(even, odd) Optimize space complexityDetermine the parity directly when traversing the input, and then add 1 to the result of the parity 1234567891011# O(n) time | O(1) spaceclass Solution: def minCostToMoveChips(self, position: List[int]) -&gt; int: odd, even = 0, 0 for val in position: if val % 2 == 0: even += 1 else: odd += 1 return min(even, odd) Pythonic VersionDetermine if it is odd: cur % 2 &#x3D;&#x3D; 1 cur &amp; 1 &amp;It is a bitwise AND operation. In bitwise binary operations, the two numbers in their binary form are processed by their corresponding bits. So 1 is only one bit. It will be compared to last bit of a number. So a&amp;1 will return 1 if last bit of 1 is 1 and zero otherwise. :&#x3D;starting in Python 3.8, := is actually a valid operator that allows for assignment of variables within expressions 123class Solution: def minCostToMoveChips(self, position: List[int]) -&gt; int: return min(odds := sum(p &amp; 1 for p in position), len(position) - odds) 1.1217. Minimum Cost to Move Chips to The Same Position ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Greedy","slug":"Greedy","permalink":"http://hexuanweng.github.io/tags/Greedy/"}]},{"title":"LC648 - Replace Words","slug":"LC648ReplaceWords","date":"2022-07-07T00:57:48.000Z","updated":"2022-07-07T00:57:48.000Z","comments":true,"path":"2022/07/07/LC648ReplaceWords/","permalink":"http://hexuanweng.github.io/2022/07/07/LC648ReplaceWords/","excerpt":"","text":"DescriptionIn English, we have a concept called root, which can be followed by some other word to form another longer word - let’s call this word successor. For example, when the root “an” is followed by the successor word “other”, we can form a new word “another”.Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the successors in the sentence with the root forming it. If a successor can be replaced by more than one root, replace it with the root that has the shortest length.Return the sentence after the replacement. Example 1:Input: dictionary &#x3D; [“cat”,”bat”,”rat”], sentence &#x3D; “the cattle was rattled by the battery”Output: “the cat was rat by the bat” Example 2:Input: dictionary &#x3D; [“a”,”b”,”c”], sentence &#x3D; “aadsfasf absbs bbab cadsfafs”Output: “a a b c” Constraints:1 &lt;&#x3D; dictionary.length &lt;&#x3D; 10001 &lt;&#x3D; dictionary[i].length &lt;&#x3D; 100dictionary[i] consists of only lower-case letters.1 &lt;&#x3D; sentence.length &lt;&#x3D; 106sentence consists of only lower-case letters and spaces.The number of words in sentence is in the range [1, 1000]The length of each word in sentence is in the range [1, 1000]Every two consecutive words in sentence will be separated by exactly one space.sentence does not have leading or trailing spaces. Solution Put all the words in the dictionary into the hash set (word in dictionary is faster in the hash set, if it is a list, it will require O(n) complexity) Split the sentence into several words according to spaces Traverse each word, if the current word appears in the hash set, replace the word and break the loop 1234567891011121314# O(n^2) time | O(n) spaceclass Solution: def replaceWords(self, dictionary: List[str], sentence: str) -&gt; str: words = sentence.split() dictionary = set(dictionary) for w in range(len(words)): for i in range(len(words[w])): if words[w][:i] in dictionary: words[w] = words[w][:i] break return &#x27; &#x27;.join(words)#Runtime: 206 ms, faster than 52.69% of Python3 online submissions for Replace Words.#Memory Usage: 18.3 MB, less than 98.64% of Python3 online submissions for Replace Words. To-do: Trie 1.648. Replace Words ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Hashmap","slug":"Hashmap","permalink":"http://hexuanweng.github.io/tags/Hashmap/"}]},{"title":"LC1162 - as Far From Land as Possible","slug":"LC1162AsFarFromLandAsPossible","date":"2022-07-06T11:56:14.000Z","updated":"2022-07-06T11:56:14.000Z","comments":true,"path":"2022/07/06/LC1162AsFarFromLandAsPossible/","permalink":"http://hexuanweng.github.io/2022/07/06/LC1162AsFarFromLandAsPossible/","excerpt":"","text":"DescriptionGiven an n x n grid containing only values 0 and 1, where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return -1.The distance used in this problem is the Manhattan distance: the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|. Example 1: Input: grid &#x3D; [[1,0,1],[0,0,0],[1,0,1]]Output: 2Explanation: The cell (1, 1) is as far as possible from all the land with distance 2. Example 2: Input: grid &#x3D; [[1,0,0],[0,0,0],[0,0,0]]Output: 4Explanation: The cell (2, 2) is as far as possible from all the land with distance 4. Constraints:n &#x3D;&#x3D; grid.lengthn &#x3D;&#x3D; grid[i].length1 &lt;&#x3D; n &lt;&#x3D; 100grid[i][j] is 0 or 1 SolutionThis question can be done using the multi-source breadth-first search method I did yesterday First save the coordinates of the current land to the queue Then start the breadth-first search through these coordinates In the process of traversing, the distance should be reduced by 1 Note: because if it is all land or all water, it returns -1 1234567891011121314151617181920212223# O(n^2) time | O(n^2) space from collections import dequeclass Solution: def maxDistance(self, grid: List[List[int]]) -&gt; int: n = len(grid) queue = deque([]) for r in range(n): for c in range(n): if grid[r][c]: queue.append((r,c)) maxi = -1 while queue: row, col = queue.popleft() for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)]: nx, ny = row+dx, col+dy if 0&lt;= nx &lt; n and 0&lt;=ny&lt;n and grid[nx][ny] == 0: grid[nx][ny] = grid[row][col] +1 queue.append((nx,ny)) if grid[nx][ny] &gt; maxi: maxi = grid[nx][ny] -1 return maxi 1.1162. As Far from Land as Possible ↩2.1765. Map of Highest Peak ↩3.1765. Solutions ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"LC1765 - Map of Highest Peak","slug":"LC1765MapofHighestPeak","date":"2022-07-05T10:21:34.000Z","updated":"2022-07-05T10:21:34.000Z","comments":true,"path":"2022/07/05/LC1765MapofHighestPeak/","permalink":"http://hexuanweng.github.io/2022/07/05/LC1765MapofHighestPeak/","excerpt":"","text":"DescriptionYou are given an integer matrix isWater of size m x n that represents a map of land and water cells.If isWater[i][j] &#x3D;&#x3D; 0, cell (i, j) is a land cell.If isWater[i][j] &#x3D;&#x3D; 1, cell (i, j) is a water cell.You must assign each cell a height in a way that follows these rules:The height of each cell must be non-negative.If the cell is a water cell, its height must be 0.Any two adjacent cells must have an absolute height difference of at most 1. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).Find an assignment of heights such that the maximum height in the matrix is maximized.Return an integer matrix height of size m x n where height[i][j] is cell (i, j)’s height. If there are multiple solutions, return any of them. Example 1: Input: isWater &#x3D; [[0,1],[0,0]]Output: [[1,0],[2,1]]Explanation: The image shows the assigned heights of each cell.The blue cell is the water cell, and the green cells are the land cells. Example 2: Input: isWater &#x3D; [[0,0,1],[1,0,0],[0,0,0]]Output: [[1,1,0],[0,1,1],[1,2,2]]Explanation: A height of 2 is the maximum possible height of any assignment.Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted. Constraints:m &#x3D;&#x3D; isWater.lengthn &#x3D;&#x3D; isWater[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 1000isWater[i][j] is 0 or 1.There is at least one water cell. Solutions First store the iswater value of 1 (water area) in the queue Perform a breadth-first search on the queue 1234567891011121314151617181920212223# O(mn) time | O(mn) spacefrom collections import dequeclass Solution: def highestPeak(self, isWater: List[List[int]]) -&gt; List[List[int]]: m, n = len(isWater), len(isWater[0]) ans = [[val -1 for val in row] for row in isWater] queue = deque([]) # store all the water area into the queue for row in range(m): for col in range(n): if isWater[row][col] == 1: queue.append((row, col)) # bfs while queue: r, c = queue.popleft() for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]: nx, ny = r+dx, c+dy if 0&lt;= nx &lt; m and 0 &lt;= ny &lt; n and ans[nx][ny] == -1: ans[nx][ny] = ans[r][c]+1 queue.append((nx,ny)) return ans 1.1765. Map of Highest Peak ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"LC1200MinimumAbsoluteDifference","slug":"LC1200MinimumAbsoluteDifference","date":"2022-07-04T05:03:09.000Z","updated":"2022-07-04T05:03:09.000Z","comments":true,"path":"2022/07/04/LC1200MinimumAbsoluteDifference/","permalink":"http://hexuanweng.github.io/2022/07/04/LC1200MinimumAbsoluteDifference/","excerpt":"","text":"DescriptionGiven an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows a, b are from arr a &lt; b b - a equals to the minimum absolute difference of any two elements in arr Example 1:Input: arr &#x3D; [4,2,1,3]Output: [[1,2],[2,3],[3,4]]Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order. Example 2:Input: arr &#x3D; [1,3,6,10,15]Output: [[1,3]] Example 3:Input: arr &#x3D; [3,8,-10,23,19,-4,-14,27]Output: [[-14,-10],[19,23],[23,27]] Constraints:2 &lt;&#x3D; arr.length &lt;&#x3D; 105-106 &lt;&#x3D; arr[i] &lt;&#x3D; 106 SolutionThe smallest difference must exist in the difference between two adjacent numbers after sorting 12345678910111213141516171819# O(nlogn) time | O(n) spaceclass Solution: def minimumAbsDifference(self, arr: List[int]) -&gt; List[List[int]]: diff = &#123;&#125; arr.sort() for i in range(1, len(arr)): gap = arr[i] - arr[i-1] if gap not in diff: diff[gap] = [[arr[i-1], arr[i]]] else: diff[gap].append([arr[i-1], arr[i]]) minKey = float(&#x27;inf&#x27;) ans = [] for key, val in diff.items(): if key &lt; minKey: minKey= key ans = val return ans Optimize space complexity 12345678910111213141516171819# O(nlogn) time | O(1) spaceclass Solution: def minimumAbsDifference(self, arr: List[int]) -&gt; List[List[int]]: arr.sort() minDiff = arr[1] - arr[0] ans = [[arr[0], arr[1]]] if len(arr) &gt;2: for i in range(2, len(arr)): diff = arr[i] - arr[i-1] if diff &lt; minDiff: minDiff = diff ans = [[arr[i-1], arr[i]]] elif diff == minDiff: ans.append([arr[i-1], arr[i]]) return ans#Runtime: 335 ms, faster than 99.47% of Python3 online submissions for Minimum Absolute Difference.#Memory Usage: 28.8 MB, less than 83.82% of Python3 online submissions for Minimum Absolute Difference. 1.1200. Minimum Absolute Difference ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Sorting","slug":"Sorting","permalink":"http://hexuanweng.github.io/tags/Sorting/"}]},{"title":"LC871 - Minimum Number of Refueling Stops","slug":"LC871MinimumNumberofRefuelingStops","date":"2022-07-02T14:04:58.000Z","updated":"2022-07-02T14:04:58.000Z","comments":true,"path":"2022/07/03/LC871MinimumNumberofRefuelingStops/","permalink":"http://hexuanweng.github.io/2022/07/03/LC871MinimumNumberofRefuelingStops/","excerpt":"","text":"DescriptionA car travels from a starting position to a destination which is target miles east of the starting position.There are gas stations along the way. The gas stations are represented as an array stations where stations[i] &#x3D; [positioni, fueli] indicates that the ith gas station is positioni miles east of the starting position and has fueli liters of gas.The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.Return the minimum number of refueling stops the car must make in order to reach its destination. If it cannot reach the destination, return -1.Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived. Example 1:Input: target &#x3D; 1, startFuel &#x3D; 1, stations &#x3D; []Output: 0Explanation: We can reach the target without refueling. Example 2:Input: target &#x3D; 100, startFuel &#x3D; 1, stations &#x3D; [[10,100]]Output: -1Explanation: We can not reach the target (or even the first gas station). Example 3:Input: target &#x3D; 100, startFuel &#x3D; 10, stations &#x3D; [[10,60],[20,30],[30,30],[60,40]]Output: 2Explanation: We start with 10 liters of fuel.We drive to position 10, expending 10 liters of fuel. We refuel from 0 liters to 60 liters of gas.Then, we drive from position 10 to position 60 (expending 50 liters of fuel),and refuel from 10 liters to 50 liters of gas. We then drive to and reach the target.We made 2 refueling stops along the way, so we return 2. Constraints:1 &lt;&#x3D; target, startFuel &lt;&#x3D; 1090 &lt;&#x3D; stations.length &lt;&#x3D; 5000 &lt;&#x3D; positioni &lt;&#x3D; positioni+1 &lt; target1 &lt;&#x3D; fueli &lt; 109 SolutionYou can think of passing the gas station equivalent as an opportunity to refuel at any timeThe problem is transformed into when the gas in the car is 0, select the largest gas station (implemented with a large top stack) from the gas stations that have passed by to achieve the goal of passing the least gas stationUnreachable if oil is 0 and the big top stack is empty and the current position is not at the target point Heapify in python is the smallest heap stored, so store negative numbers when storing, and then add a negative sign when fetching 123456789101112131415class Solution: def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -&gt; int: ans = 0 curFuel = startFuel heap = [] stations.append([target, 0]) for distance, fuel in stations: while curFuel &lt; distance: if not heap: return -1 curFuel += -heappop(heap) ans+=1 heappush(heap, -fuel) return ans 1.871. Minimum Number of Refueling Stops ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Greedy","slug":"Greedy","permalink":"http://hexuanweng.github.io/tags/Greedy/"},{"name":"Heap","slug":"Heap","permalink":"http://hexuanweng.github.io/tags/Heap/"}]},{"title":"LC1175 - Prime Arrangements","slug":"LC1175PrimeArrangements","date":"2022-06-30T00:52:41.000Z","updated":"2022-06-30T00:52:41.000Z","comments":true,"path":"2022/06/30/LC1175PrimeArrangements/","permalink":"http://hexuanweng.github.io/2022/06/30/LC1175PrimeArrangements/","excerpt":"","text":"DescriptionReturn the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)Since the answer may be large, return the answer modulo 10^9 + 7. Example 1:Input: n &#x3D; 5Output: 12Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1. Example 2:Input: n &#x3D; 100Output: 682289015 Constraints:1 &lt;&#x3D; n &lt;&#x3D; 100 Solution First get the number of prime numbers in n numbers Then get the number of non-prime numbers &#x3D; n - the number of prime numbers The answer is obtained by multiplying the number of permutations of prime numbers by the number of permutations of non-primes. 123456789101112131415161718192021# O(n) time | O(n) spaceclass Solution: def numPrimeArrangements(self, n: int) -&gt; int: primecnt = 0 mod = 1e9+7 ans = 1 for i in range(2, n+1): for j in range(2, i): if i % j == 0: break else: primecnt+=1 for i in range(1, primecnt+1): ans *= i ans %= mod for i in range(1, n-primecnt+1): ans *= i ans %= mod return int(ans) How to find prime numbers in a range12345678910num = [];n = 100for i in range(2, n): for j in range(2, i): if (i % j == 0): break # This else executes only if break is NEVER reached and loop terminated after all iterations. else: num.append(i)print(num) FactorialFor Loop12345678ans = 1mod = 1e9+7n = 10for i in range(1, n+1): ans *= i # if the number is too large ans %= modprint(ans) Reduce Function1234from functools import reducen = 10ans = reduce(lambda x, y: x*y, range(1, n+1))print(ans) Recursion12345678def factorial(n): if n == 0 or n ==1: return 1 else: return (n*factorial(n-1))ans = factorial(10)print(ans) 1.1175. Prime Arrangements ↩2.Using else conditional statement with for loop in python ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Math","slug":"Math","permalink":"http://hexuanweng.github.io/tags/Math/"}]},{"title":"LC535 - Encode and Decode TinyURL","slug":"LC535EndoceandDecodeTinyURL","date":"2022-06-29T12:28:20.000Z","updated":"2022-06-29T12:28:20.000Z","comments":true,"path":"2022/06/29/LC535EndoceandDecodeTinyURL/","permalink":"http://hexuanweng.github.io/2022/06/29/LC535EndoceandDecodeTinyURL/","excerpt":"","text":"DescriptionNote: This is a companion problem to the System Design problem: Design TinyURL.TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL.There is no restriction on how your encode&#x2F;decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.Implement the Solution class:Solution() Initializes the object of the system.String encode(String longUrl) Returns a tiny URL for the given longUrl.String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object. Example 1:Input: url &#x3D; “https://leetcode.com/problems/design-tinyurl“Output: “https://leetcode.com/problems/design-tinyurl“Explanation:Solution obj &#x3D; new Solution();string tiny &#x3D; obj.encode(url); &#x2F;&#x2F; returns the encoded tiny url.string ans &#x3D; obj.decode(tiny); &#x2F;&#x2F; returns the original url after deconding it. Constraints:1 &lt;&#x3D; url.length &lt;&#x3D; 104url is guranteed to be a valid URL. Solution Hash algorithm, accepts incoming content, and obtains a string of hash values after operation As long as the incoming content is the same, the obtained hash value must be the same Cannot be converted into content by hash value As long as the hash algorithm used remains the same, the length of the obtained hash value is fixed no matter how large the content to be verified is 1234567891011121314151617181920212223import hashlibclass Codec: def __init__(self): self.map = &#123;&#125; def encode(self, longUrl: str) -&gt; str: &quot;&quot;&quot;Encodes a URL to a shortened URL. &quot;&quot;&quot; message = longUrl.encode() en = hashlib.md5(message).hexdigest() self.map[en] = longUrl return f&quot;https://hex.com/&#123;en&#125;&quot; def decode(self, shortUrl: str) -&gt; str: &quot;&quot;&quot;Decodes a shortened URL to its original URL. &quot;&quot;&quot; key = shortUrl.split(&quot;/&quot;)[-1] return self.map[key]# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.decode(codec.encode(url)) Notes1234567891011121314151617import hashlib# encode it to bytes using UTF-8 encodingmessage = &quot;Some text to hash&quot;.encode()# hash with MD5 (not recommended)print(&quot;MD5:&quot;, hashlib.md5(message).hexdigest())# hash with SHA-2 (SHA-256 &amp; SHA-512)print(&quot;SHA-256:&quot;, hashlib.sha256(message).hexdigest())print(&quot;SHA-512:&quot;, hashlib.sha512(message).hexdigest())# hash with SHA-3print(&quot;SHA-3-256:&quot;, hashlib.sha3_256(message).hexdigest())print(&quot;SHA-3-512:&quot;, hashlib.sha3_512(message).hexdigest())# hash with BLAKE2# 256-bit BLAKE2 (or BLAKE2s)print(&quot;BLAKE2c:&quot;, hashlib.blake2s(message).hexdigest())# 512-bit BLAKE2 (or BLAKE2b)print(&quot;BLAKE2b:&quot;, hashlib.blake2b(message).hexdigest()) 1.535. Encode and Decode TinyURL ↩2.How to Use Hashing Algorithms in Python using hashlib ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Hashmap","slug":"Hashmap","permalink":"http://hexuanweng.github.io/tags/Hashmap/"}]},{"title":"LC710 - Random Pick With Blacklist","slug":"LC710RandomPickwithBlacklist","date":"2022-06-26T09:36:24.000Z","updated":"2022-06-26T09:36:24.000Z","comments":true,"path":"2022/06/26/LC710RandomPickwithBlacklist/","permalink":"http://hexuanweng.github.io/2022/06/26/LC710RandomPickwithBlacklist/","excerpt":"","text":"DescriptionYou are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. Any integer that is in the mentioned range and not in blacklist should be equally likely to be returned.Optimize your algorithm such that it minimizes the number of calls to the built-in random function of your language.Implement the Solution class:Solution(int n, int[] blacklist) Initializes the object with the integer n and the blacklisted integers blacklist.int pick() Returns a random integer in the range [0, n - 1] and not in blacklist. Example 1:Input[“Solution”, “pick”, “pick”, “pick”, “pick”, “pick”, “pick”, “pick”][[7, [2, 3, 5]], [], [], [], [], [], [], []]Output[null, 0, 4, 1, 6, 1, 0, 4]ExplanationSolution solution &#x3D; new Solution(7, [2, 3, 5]);solution.pick(); &#x2F;&#x2F; return 0, any integer from [0,1,4,6] should be ok. Note that for every call of pick, &#x2F;&#x2F; 0, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1&#x2F;4).solution.pick(); &#x2F;&#x2F; return 4solution.pick(); &#x2F;&#x2F; return 1solution.pick(); &#x2F;&#x2F; return 6solution.pick(); &#x2F;&#x2F; return 1solution.pick(); &#x2F;&#x2F; return 0solution.pick(); &#x2F;&#x2F; return 4 Constraints:1 &lt;&#x3D; n &lt;&#x3D; 1090 &lt;&#x3D; blacklist.length &lt;&#x3D; min(105, n - 1)0 &lt;&#x3D; blacklist[i] &lt; nAll the values of blacklist are unique.At most 2 * 104 calls will be made to pick. SolutionThere are N numbers in total, of which there are len(blacklist) numbers on the blacklist, and N-len(blacklist) numbers on the whitelist. In order to use random.randint(0, self.white_len - 1) to get white_len numbers randomly One of the list numbers, using the mapping to handle numbers in the first white_len positions that are not part of the whitelist. 123456789101112131415161718192021# Solution O(m) time, Pick O(1) time | O(m) spaceclass Solution: def __init__(self, n: int, blacklist: List[int]): self.wl = n - len(blacklist) blacks = [i for i in blacklist if i &lt; self.wl] whites = [i for i in range(self.wl, n) if i not in blacklist] self.blackwhite = &#123;&#125; for i in range(len(blacks)): self.blackwhite[blacks[i]] = whites[i] def pick(self) -&gt; int: num = random.randint(0, self.wl-1) if num in self.blackwhite: return self.blackwhite[num] else: return num# Your Solution object will be instantiated and called as such:# obj = Solution(n, blacklist)# param_1 = obj.pick() Version2 12345678910111213141516171819202122232425class Solution: def __init__(self, n: int, blacklist: List[int]): self.bound = n - len(blacklist) blacks = [i for i in blacklist if i &gt;= self.bound] self.pairs = &#123;&#125; # idx is the starting point of the latter list to filter out white items idx = self.bound for i in blacklist: if i &lt; self.bound: while idx in blacks: idx +=1 self.pairs[i] = idx idx+=1 def pick(self) -&gt; int: num = random.randint(0, self.bound-1) if num in self.pairs: return self.pairs[num] else: return num # Your Solution object will be instantiated and called as such:# obj = Solution(n, blacklist)# param_1 = obj.pick() 1.710. Random Pick with Blacklist ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Hashmap","slug":"Hashmap","permalink":"http://hexuanweng.github.io/tags/Hashmap/"}]},{"title":"LC732 - My Calenar III","slug":"LC732MyCalenarIII","date":"2022-06-25T10:36:18.000Z","updated":"2022-06-25T10:36:18.000Z","comments":true,"path":"2022/06/25/LC732MyCalenarIII/","permalink":"http://hexuanweng.github.io/2022/06/25/LC732MyCalenarIII/","excerpt":"","text":"DescriptionA k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.)You are given some events [start, end), after each given event, return an integer k representing the maximum k-booking between all the previous events.Implement the MyCalendarThree class:MyCalendarThree() Initializes the object.int book(int start, int end) Returns an integer k representing the largest integer such that there exists a k-booking in the calendar. Example 1:Input[“MyCalendarThree”, “book”, “book”, “book”, “book”, “book”, “book”][[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]Output[null, 1, 1, 2, 3, 3, 3] ExplanationMyCalendarThree myCalendarThree &#x3D; new MyCalendarThree();myCalendarThree.book(10, 20); &#x2F;&#x2F; return 1, The first event can be booked and is disjoint, so the maximum k-booking is a 1-booking.myCalendarThree.book(50, 60); &#x2F;&#x2F; return 1, The second event can be booked and is disjoint, so the maximum k-booking is a 1-booking.myCalendarThree.book(10, 40); &#x2F;&#x2F; return 2, The third event [10, 40) intersects the first event, and the maximum k-booking is a 2-booking.myCalendarThree.book(5, 15); &#x2F;&#x2F; return 3, The remaining events cause the maximum K-booking to be only a 3-booking.myCalendarThree.book(5, 10); &#x2F;&#x2F; return 3myCalendarThree.book(25, 55); &#x2F;&#x2F; return 3 Constraints:0 &lt;&#x3D; start &lt; end &lt;&#x3D; 109At most 400 calls will be made to book. Solution A sorted dictionary needs to be maintained, where the key is the value of start and end in each time period, and the value is the number of occurrences corresponding to it In differential thinking, we only need to maintain start and end (end is not included). Just set start +&#x3D;1, end -&#x3D;1 Then add them one by one using the prefix sum, so you can know how many times this schedule overlaps. According to the meaning of the question, keep the maximum value and return the maximum value. 123456789101112131415161718192021222324252627# O(n^2) time | O(n) spacefrom sortedcontainers import SortedDictclass MyCalendarThree: def __init__(self): self.booking = SortedDict() def book(self, start: int, end: int) -&gt; int: if start not in self.booking: self.booking[start] = 1 else: self.booking[start] +=1 if end not in self.booking: self.booking[end] =-1 else: self.booking[end] -=1 presum = 0 ans = 0 for i, v in self.booking.items(): presum += v ans = max(ans, presum) return ans# Your MyCalendarThree object will be instantiated and called as such:# obj = MyCalendarThree()# param_1 = obj.book(start,end) 1.729. My Calendar I ↩2.731. My Calendar II ↩3.732. My Calendar III ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Difference Array","slug":"Difference-Array","permalink":"http://hexuanweng.github.io/tags/Difference-Array/"}]},{"title":"LC731 - My Calendar II","slug":"LC729MyCalendarII","date":"2022-06-25T10:25:59.000Z","updated":"2022-06-25T10:25:59.000Z","comments":true,"path":"2022/06/25/LC729MyCalendarII/","permalink":"http://hexuanweng.github.io/2022/06/25/LC729MyCalendarII/","excerpt":"","text":"DescriptionYou are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.A triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start &lt;&#x3D; x &lt; end.Implement the MyCalendarTwo class:MyCalendarTwo() Initializes the calendar object.boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar. Example 1:Input[“MyCalendarTwo”, “book”, “book”, “book”, “book”, “book”, “book”][[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]Output[null, true, true, true, false, true, true]ExplanationMyCalendarTwo myCalendarTwo &#x3D; new MyCalendarTwo();myCalendarTwo.book(10, 20); &#x2F;&#x2F; return True, The event can be booked.myCalendarTwo.book(50, 60); &#x2F;&#x2F; return True, The event can be booked.myCalendarTwo.book(10, 40); &#x2F;&#x2F; return True, The event can be double booked.myCalendarTwo.book(5, 15); &#x2F;&#x2F; return False, The event cannot be booked, because it would result in a triple booking.myCalendarTwo.book(5, 10); &#x2F;&#x2F; return True, The event can be booked, as it does not use time 10 which is already double booked.myCalendarTwo.book(25, 55); &#x2F;&#x2F; return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event. Constraints:0 &lt;&#x3D; start &lt; end &lt;&#x3D; 109At most 1000 calls will be made to book. Solutions A sorted dictionary needs to be maintained, where the key is the value of start and end in each time period, and the value is the number of occurrences corresponding to it In differential thinking, we only need to maintain start and end (end is not included). Just set start +&#x3D;1, end -&#x3D;1 Then add them one by one using the prefix sum, so you can know how many times this schedule overlaps. According to the meaning of the question, if the overlap value &gt; 2, return False. 123456789101112131415161718192021222324252627282930#O(n^2) time | O(n) spacefrom sortedcontainers import SortedDictclass MyCalendarTwo: def __init__(self): self.booking = SortedDict() def book(self, start: int, end: int) -&gt; bool: if start in self.booking: self.booking[start] +=1 else: self.booking[start] = 1 if end in self.booking: self.booking[end] -=1 else: self.booking[end] =-1 presum = 0 for i, v in self.booking.items(): presum+=v if presum &gt;2: self.booking[start] -=1 self.booking[end] +=1 return False return True# Your MyCalendarTwo object will be instantiated and called as such:# obj = MyCalendarTwo()# param_1 = obj.book(start,end) 1.729. My Calendar I ↩2.731. My Calendar II ↩3.732. My Calendar III ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Difference Array","slug":"Difference-Array","permalink":"http://hexuanweng.github.io/tags/Difference-Array/"}]},{"title":"LC729 - My Calendar I","slug":"LC729MyCalendarI","date":"2022-06-25T10:13:36.000Z","updated":"2022-06-25T10:13:36.000Z","comments":true,"path":"2022/06/25/LC729MyCalendarI/","permalink":"http://hexuanweng.github.io/2022/06/25/LC729MyCalendarI/","excerpt":"","text":"DescriptionYou are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start &lt;&#x3D; x &lt; end.Implement the MyCalendar class:MyCalendar() Initializes the calendar object.boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. Example 1:Input[“MyCalendar”, “book”, “book”, “book”][[], [10, 20], [15, 25], [20, 30]]Output[null, true, false, true]ExplanationMyCalendar myCalendar &#x3D; new MyCalendar();myCalendar.book(10, 20); &#x2F;&#x2F; return TruemyCalendar.book(15, 25); &#x2F;&#x2F; return False, It can not be booked because time 15 is already booked by another event.myCalendar.book(20, 30); &#x2F;&#x2F; return True, The event can be booked, as the first event takes every time less than 20, but not including 20. Constraints:0 &lt;&#x3D; start &lt; end &lt;&#x3D; 109At most 1000 calls will be made to book. SolutionsBrute Force Check whether [start, end] can be added to MyCalendar, which can be compared by comparing the relationship between [s,e] and [start, end] e ≤ start or end ≤ s are all satisfied That is, e &gt; start and end &gt; s, there is overlap 1234567891011121314151617181920#O(n^2) time | O(n) spaceclass MyCalendar: def __init__(self): self.booking = [] def book(self, start: int, end: int) -&gt; bool: for s, e in self.booking: if e &lt;= start: continue if s &gt;= end: continue return False self.booking.append((start, end)) return True # Your MyCalendar object will be instantiated and called as such:# obj = MyCalendar()# param_1 = obj.book(start,end) SortedDictSimilar to the first method, but this method uses a SortedDict to store the data. This ordered dictionary is useful for handling boundaries in the next method. 123456789101112131415161718192021# O(n^2) time | O(n) spacefrom sortedcontainers import SortedDictclass MyCalendar: def __init__(self): self.booking = SortedDict() def book(self, start: int, end: int) -&gt; bool: for s, e in self.booking.items(): if e &lt;= start: continue if s &gt;= end: continue return False self.booking[start] = end return True # Your MyCalendar object will be instantiated and called as such:# obj = MyCalendar()# param_1 = obj.book(start,end) Difference ArrayThis method can be used in MyCalendar2 and MyCalendar3 A sorted dictionary needs to be maintained, where the key is the value of start and end in each time period, and the value is the number of occurrences corresponding to it In differential thinking, we only need to maintain start and end (end is not included). Just set start +&#x3D;1, end -&#x3D;1 Then add them one by one using the prefix sum, so you can know how many times this schedule overlaps. According to the meaning of the question, if there is overlap, return False 12345678910111213141516171819202122232425262728293031# O(n^2) time | O(n) spacefrom sortedcontainers import SortedDictclass MyCalendar: def __init__(self): self.booking = SortedDict() def book(self, start: int, end: int) -&gt; bool: if start not in self.booking: self.booking[start] =1 else: self.booking[start]+=1 if end not in self.booking: self.booking[end] =-1 else: self.booking[end] -=1 presum = 0 for i,v in self.booking.items(): presum+=v if presum &gt; 1: self.booking[start] -=1 self.booking[end] +=1 return False return True # Your MyCalendar object will be instantiated and called as such:# obj = MyCalendar()# param_1 = obj.book(start,end) 1.729. My Calendar I ↩2.731. My Calendar II ↩3.732. My Calendar III ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Brute Force","slug":"Brute-Force","permalink":"http://hexuanweng.github.io/tags/Brute-Force/"},{"name":"Difference Array","slug":"Difference-Array","permalink":"http://hexuanweng.github.io/tags/Difference-Array/"}]},{"title":"LC515 - Find Largest Value in Each TreeRow","slug":"LC515FindLargestValueinEachTreeRow","date":"2022-06-24T02:28:54.000Z","updated":"2022-06-24T02:28:54.000Z","comments":true,"path":"2022/06/24/LC515FindLargestValueinEachTreeRow/","permalink":"http://hexuanweng.github.io/2022/06/24/LC515FindLargestValueinEachTreeRow/","excerpt":"","text":"DescriptionGiven the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).Example 1: Input: root &#x3D; [1,3,2,5,3,null,9]Output: [1,3,9] Example 2:Input: root &#x3D; [1,2,3]Output: [1,3] Constraints:The number of nodes in the tree will be in the range [0, 104].-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1 Solution 1234567891011121314151617181920212223242526# O(n) time | O(n) space# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def largestValues(self, root: Optional[TreeNode]) -&gt; List[int]: if root is None: return [] queue = collections.deque([root]) ans = [] while queue: l = len(queue) maxi = float(&#x27;-inf&#x27;) for i in range(l): pop_node = queue.popleft() maxi = max(maxi, pop_node.val) if pop_node.left: queue.append(pop_node.left) if pop_node.right: queue.append(pop_node.right) ans.append(maxi) return ans 1.515. Find Largest Value in Each Tree Row ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"LC30 - Substring With Concatenation of All Words","slug":"LC30SubstringwithConcatenationofAllWords","date":"2022-06-24T01:11:16.000Z","updated":"2022-06-24T01:11:16.000Z","comments":true,"path":"2022/06/24/LC30SubstringwithConcatenationofAllWords/","permalink":"http://hexuanweng.github.io/2022/06/24/LC30SubstringwithConcatenationofAllWords/","excerpt":"","text":"DescriptionYou are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.You can return the answer in any order. Example 1:Input: s &#x3D; “barfoothefoobarman”, words &#x3D; [“foo”,”bar”]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are “barfoo” and “foobar” respectively.The output order does not matter, returning [9,0] is fine too. Example 2:Input: s &#x3D; “wordgoodgoodgoodbestword”, words &#x3D; [“word”,”good”,”best”,”word”]Output: [] Example 3:Input: s &#x3D; “barfoofoobarthefoobarman”, words &#x3D; [“bar”,”foo”,”the”]Output: [6,9,12] Constraints:1 &lt;&#x3D; s.length &lt;&#x3D; 104s consists of lower-case English letters.1 &lt;&#x3D; words.length &lt;&#x3D; 50001 &lt;&#x3D; words[i].length &lt;&#x3D; 30words[i] consists of lower-case English letters. SolutionsSolved with a sliding window and two HashMaps. We store all the words in the HashMap, the key directly stores the word, and the value stores the number of occurrences of the word (because the given word may be repeated, so it may be 1 or 2 or other). Scan the words of the substring, if the word currently scanned is in the previous HashMap, store the word in the new HashMap The substring scan ends, if all the words of the substring match, then the substring is one of the ones we are looking for 1234567891011121314151617181920212223242526class Solution: def findSubstring(self, s: str, words: List[str]) -&gt; List[int]: hashWords = &#123;&#125; for word in words: if word not in hashWords: hashWords[word] = 1 else: hashWords[word] +=1 i, j = 0, len(words)*len(words[0])-1 ans = [] while j &lt; len(s): sub = s[i:j+1] temp = &#123;&#125; for k in range(0, j-i+1, len(words[0])): cur = sub[k:k+len(words[0])] if cur not in temp: temp[cur] =1 else: temp[cur]+=1 if temp == hashWords: ans.append(i) i+=1 j+=1 return ans use libraray collections.Counter 1234567891011121314151617181920class Solution: def findSubstring(self, s: str, words: List[str]) -&gt; List[int]: wl, wsl = len(words[0]), len(words) i, j = 0, wl*wsl -1 ans = [] wordsHash = collections.Counter(words) while j &lt; len(s): sub = s[i:j+1] subs = [] for k in range(0, j-i+1, wl): subs.append(sub[k:k+wl]) subsHash = collections.Counter(subs) if wordsHash == subsHash: ans.append(i) i+=1 j+=1 return ans Note1234567891011121314&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt;&gt;&gt;&gt; myList = [1,1,2,3,4,5,3,2,3,4,2,1,2,3]&gt;&gt;&gt; print Counter(myList)Counter(&#123;2: 4, 3: 4, 1: 3, 4: 2, 5: 1&#125;)&gt;&gt;&gt;&gt;&gt;&gt; print Counter(myList).items()[(1, 3), (2, 4), (3, 4), (4, 2), (5, 1)]&gt;&gt;&gt;&gt;&gt;&gt; print Counter(myList).keys()[1, 2, 3, 4, 5]&gt;&gt;&gt;&gt;&gt;&gt; print Counter(myList).values()[3, 4, 4, 2, 1] 1.30. Substring with Concatenation of All Words ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"hard","slug":"hard","permalink":"http://hexuanweng.github.io/tags/hard/"},{"name":"Hashmap","slug":"Hashmap","permalink":"http://hexuanweng.github.io/tags/Hashmap/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://hexuanweng.github.io/tags/Two-Pointers/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://hexuanweng.github.io/tags/Sliding-Window/"}]},{"title":"LC1537 - Get the Maximum Score","slug":"LC1537GettheMaximumScore","date":"2022-06-23T11:11:15.000Z","updated":"2022-06-23T11:11:15.000Z","comments":true,"path":"2022/06/23/LC1537GettheMaximumScore/","permalink":"http://hexuanweng.github.io/2022/06/23/LC1537GettheMaximumScore/","excerpt":"","text":"DescriptionYou are given two sorted arrays of distinct integers nums1 and nums2.A valid path is defined as follows: Choose array nums1 or nums2 to traverse (from index-0). Traverse the current array from left to right. If you are reading any value that is present in nums1 and nums2 you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path). The score is defined as the sum of uniques values in a valid path.Return the maximum score you can obtain of all possible valid paths. Since the answer may be too large, return it modulo 10^9 + 7. Example 1: Input: nums1 &#x3D; [2,4,5,8,10], nums2 &#x3D; [4,6,8,9]Output: 30Explanation: Valid paths:[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10], (starting from nums1)[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10] (starting from nums2)The maximum is obtained with the path in green [2,4,6,8,10]. Example 2:Input: nums1 &#x3D; [1,3,5,7,9], nums2 &#x3D; [3,5,100]Output: 109Explanation: Maximum sum is obtained with the path [1,3,5,100]. Example 3:Input: nums1 &#x3D; [1,2,3,4,5], nums2 &#x3D; [6,7,8,9,10]Output: 40Explanation: There are no common elements between nums1 and nums2.Maximum sum is obtained with the path [6,7,8,9,10]. Constraints:1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 1051 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 107nums1 and nums2 are strictly increasing. Solutions Definition: “fork” – encountered a value that exists in both nums1 and nums2 Use two pointers i, j to traverse the arrays nums1 and nums2 from the beginning, respectively, the current sum is recorded as sum1, sum2 In order for the two pointers to meet at the fork, we take advantage of the ordering of the array and move the pointer with the smaller value forward one step at a time. At the fork, we assign sum1 and sum2 to the larger of the two (greedy), plus the value of the current fork, so that both pointers move forward (it can be understood that this fork is the new starting point) , and update the base value to the larger sum of the previous two paths, and start again). Repeat this cycle until a path comes to an end. Two paths, one of which may not be completed, so we add the remaining numbers in the array to it. 1234567891011121314151617181920212223242526# O(n) time | O(1) spaceclass Solution: def maxSum(self, nums1: List[int], nums2: List[int]) -&gt; int: i, j, sum1, sum2 = 0, 0, 0, 0 mod = 1000000007 len1 = len(nums1) len2 = len(nums2) while i &lt; len1 and j &lt; len2: num1 = nums1[i] num2 = nums2[j] if num1 &lt; num2: sum1 += num1 i+=1 elif num1 &gt; num2: sum2 += num2 j+=1 else: sum1 = sum2 = (max(sum1, sum2) + num1) % mod i+=1 j+=1 if i &lt; len1: sum1+=sum(nums1[i:]) if j &lt; len2: sum2+=sum(nums2[j:]) return max(sum1, sum2)%mod NoteIn most programming competitions, we are required to answer the result in 10^9+7 modulo. The reason behind this is, if problem constraints are large integers, only efficient algorithms can solve them in an allowed limited time. 12mod = 1000000007mod = int(math.pow(10,9)+7) 1.1537. Get the Maximum Score ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"hard","slug":"hard","permalink":"http://hexuanweng.github.io/tags/hard/"},{"name":"Greedy","slug":"Greedy","permalink":"http://hexuanweng.github.io/tags/Greedy/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://hexuanweng.github.io/tags/Two-Pointers/"}]},{"title":"Android Development（Kotlin）- Kotlin Language Fundamentals & Activity Life Cycle","slug":"AndroidDevelopmentDay2","date":"2022-06-22T11:57:21.000Z","updated":"2022-06-22T11:57:21.000Z","comments":true,"path":"2022/06/22/AndroidDevelopmentDay2/","permalink":"http://hexuanweng.github.io/2022/06/22/AndroidDevelopmentDay2/","excerpt":"","text":"Day2: Kotlin Language Fundamentals &amp; Activity Life CycleKotlin FundamentalsKotlin Docs | Kotlin Keywords and operators | Kotlin Installation123 ~/ brew install kotlin ~/ kotlin -versionKotlin version 1.5.31-release-548 (JRE 17.0.2+8-LTS-86) Create and Run an ApplicationCreate a simple application in Kotlin that displays &quot;Hello, World!&quot;. In your favorite editor, create a new file called hello.kt with the following lines: 123fun main() &#123; println(&quot;Hello, World!&quot;)&#125; 1kotlinc hello.kt -include-runtime -d hello.jar &amp;&amp; java -jar hello.jar Definition What is compilation? Compilation is the process that translates the program written in a programming language into byte codes that the system can run. What is a program? A program is a set of instructions we provide to a system to get a task done. Example fun declares a function. unit for the functions that do not return anything. The type with only one value: the Unit object. This type corresponds to the void type in Java. val declares a read-only property or local variable. var declares a mutable property or local variable. Variables must either have a type annotation or be initialized 1234567891011121314151617181920212223242526272829303132333435363738394041fun main()&#123; var first_name = 12 var second_name = 8 cal(first_name, second_name) var summ = getAddition(39, 32) println(&quot;Total is $summ - example1&quot;) println(&quot;Total is $&#123;getAddition(1,2, 10)&#125; - example2&quot;) var fruits : List&lt;String&gt; = listOf(&quot;Banana&quot;, &quot;Apple&quot;, &quot;Mongo&quot;) getFruits(fruits)&#125;fun cal(first_name: Int, second_name: Int ):Unit&#123; //a type annotation is required on a value parameters println(&quot;------------------------------------&quot;) println(&quot;Calculation Started:&quot;) println(&quot;First number is $first_name&quot;) println(&quot;Second number is $second_name&quot;) println(&quot;Addition of them is $&#123;first_name+second_name&#125;&quot;) println(&quot;Subtraction of them is $&#123;first_name-second_name&#125;&quot;) println(&quot;Calculation Ended.&quot;) println(&quot;------------------------------------&quot;)&#125;fun getAddition(num1: Int, num2:Int): Int&#123; return num1+num2&#125;// overloaded functionfun getAddition(num1: Int, num2: Int, num3: Int):Int&#123; return num1+num2+num3&#125;// for eachfun getFruits(fruits: List&lt;String&gt;)&#123; println(&quot;Size of the fruit is $&#123;fruits.size&#125;.&quot;) fruits.forEach&#123; i -&gt; println(&quot;This is $i&quot;) &#125;&#125; Android Activity Lifecycle Fragments life cycle is similiar to activity life cycle. onCreate() When we launch the activity, it comes to onCreate() state. At that time, android system will invoke activity instances on create callback function. In the onCreate() function, we perform basic application start up logic that should happen only once for the entire life of the activity. onCreate() is the must have function. onCreate() function is the only compulsory lifecycle function. The other lifecycle functions are optional. We don’t have to overwrite them unless we need to use them. 12345678java.lang.Object ↳ android.content.Context ↳ android.content.ContextWrapper ↳ android.view.ContextThemeWrapper ↳ android.app.Activity ↳ androidx.activity.ComponentActivity ↳ androidx.fragment.app.FragmentActivity ↳ androidx.appcompat.app.AppCompatActivity onStart() After the onCreate() method finishes execution, the activity enters to the onStart() state. The onStart() function of the activity class prepares the activity to enter the foreground and become interactive. Foreground is where the app initializes, and the code that creates the user interface onResume() The system calls the onStart() and onResume() in a quick succesion. During the onResume() state, app comes to the foreground. This is the state which the activity interacts with the user Common practice: reconnecting with the server to load media files initialize the camera Activity RunningWhen this happen, onResume() function will be called. Activity stays in the resumed state until something happens to take focus away from it. onPause() when following events happen, activity will transit to onPause() state. user navigates into another activity user receives the phone call device screens turning off screen rotation If the activity returns to the onResume() state from onPause() state, the system once again calls onResume() method. if our app requires something to initialize every time it resumed, we should overwrite the onResume() function and add code there The system calls the onPause() function and take the activity to onPause() state as soon as the user is leaving our activity When app is moving from foreground to the background, we should use the onPause() overridden function to pause the activity onStop() After the onPause() state, if the app is not moving to the resumed state, the system may transit activity to the stop state. When that happen, activity instance will be still there in the memory but user interface will be destroyed. If the user navigates back to the app, the system will invoke on onReseart() and onStart() functions to create the user interface again onDestroy() this function is called when the system destroying the activity. When we programmatically ignore the finish function to intentionally destroy the activity When the user makes a configuration change: rotate the screen or change the language [when this happen, the system will tempororarily destroy the activity and recreate it again in working onCreate function call.] Simulation1234567891011121314151617181920212223242526272829303132class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) Log.i(&quot;HEX&quot;, &quot;MainActivity: onCreate()&quot;) setContentView(R.layout.activity_main) &#125; override fun onStart() &#123; super.onStart() Log.i(&quot;HEX&quot;, &quot;MainActivity: OnStart()&quot;) &#125; override fun onResume() &#123; super.onResume() Log.i(&quot;HEX&quot;, &quot;MainActivity: OnResume()&quot;) &#125; override fun onPause() &#123; super.onPause() Log.i(&quot;HEX&quot;, &quot;MainActivity: onPause()&quot;) &#125; override fun onStop() &#123; super.onStop() Log.i(&quot;HEX&quot;, &quot;MainActivity: onStop()&quot;) &#125; override fun onDestroy() &#123; super.onDestroy() Log.i(&quot;HEX&quot;, &quot;MainActivity: onDestroy()&quot;) &#125;&#125; Monitor how MainActivity and MainActivity2 transit to life cycle states Launch the app MainActivity: onCreate(), onStart(), onResume() Navigate to MainActivity2 MainActivity: onPause() MainActivity2: onCreate(), onStart(), onResume() MainActivity: onStop() Click on the back button, navigate back to MainActivity1 MainActivity2: onPause() MainActivity1: onCreate(), onStart(), onResume() MainActivity: onStop(), onDestroy() Rorate the screen MainActivity1: onPause(), onStop(), onDestroy() MainActivity1: onCreate(), onStart(), onResume() Object Oriented KotlinInstance &#x3D; Object12345678910class Car&#123; fun start()&#123; println(&quot;Car is starting&quot;) &#125;&#125;fun main()&#123; var car = Car() car.start()&#125; ConstructorKotlins allows us to define the primary constructor embedded with the class definition with init block, we can add more instances or variables when we call this class. 123456789101112131415161718192021class Driver(name: String)&#123; // field variable/property var driverName = &quot;&quot; var car = Car() init&#123; driverName = name car.start() &#125; fun showDetails()&#123; println(&quot;Driver name is $&#123;driverName&#125;&quot;) &#125;&#125;fun main()&#123; val driver = Driver(&quot;Hex&quot;) driver.showDetails() driver.driverName = &quot;Hannah&quot; driver.showDetails()&#125; Lateinit When we use Lateinit, we need to always provide the object type 12345678910111213141516class Driver(name: String)&#123; lateinit var driverName : String init&#123; driverName = name &#125; fun showDetails()&#123; println(&quot;Driver name is $driverName&quot;) &#125;&#125;fun main()&#123; val driver = Driver(&quot;Hex&quot;) driver.showDetails()&#125; another way: to put field variable in the () 12345678910class Driver(var name: String)&#123; fun showDetails()&#123; println(&quot;Driver name is $name&quot;) &#125;&#125;fun main()&#123; val driver = Driver(&quot;Hex&quot;) driver.showDetails()&#125; If we use the init block, every time we create an instance of the class, the block will be executed. That means the code inside the init block is the first to be executed when the class is instantiated the function in the class will only be executed only if we invoke that function difference between property and a parameter name is a property functions can directly access a property or a field variable credit is a parameter 12345678910111213141516class Driver(var name: String, credit: Int)&#123; // field variable can be accessed by functions var totalCredit = 50 init&#123; totalCredit+= credit &#125; fun showDetails()&#123; println(&quot;Driver name is $name and total credit is $totalCredit.&quot;) &#125;&#125;fun main()&#123; val driver = Driver(&quot;Hex&quot;, 27) driver.showDetails()&#125; Visibility Modifiers public: visible to all the classes private: only visible to itself 99% of time we should make propery of a class private protected: only visible to itself and its inherited classes 123456789101112131415class Driver(var name: String, credit: Int)&#123; private var totalCredit = 50 init&#123; totalCredit+= credit &#125; fun showDetails()&#123; println(&quot;Driver name is $name and total credit is $totalCredit.&quot;) &#125;&#125;fun main()&#123; val driver = Driver(&quot;Hex&quot;, 27) driver.showDetails()&#125; InheritanceIn Kotlin, all classes are final by default. To permit the derived classes to inherit from the base class, we must use the open keyword in front of the base class Child class can: inherit the parent class’ property and function override parent classes functions. [need to make base function open before overriding] 1234567891011121314151617181920212223open class Car&#123; var maxSpeed = 30 open fun start()&#123; println(&quot;Car is starting&quot;) &#125;&#125;class MyCar : Car()&#123; override fun start()&#123; println(&quot;MyCar is starting&quot;) &#125;&#125;fun main()&#123; var car = Car() car.start() var myCar = MyCar() myCar.maxSpeed = 240 println(myCar.maxSpeed) myCar.start()&#125; Interfaces An interface can be implemented by a class in order to use its defined functionality It is a way to provide a description or a contract for classes in object-oriented programming Interfaces provide a predefined structure for a class so other classes can deal with our class properly Interfaces in Kotlin can contain declarations of abstract methods as well as method implementations Abstract methods are those don’t have method body In Kotline, interfaces can also contain method declarations If we want to inherit the interface for a class, we must implement its abstract methods too 12345678910111213141516171819202122232425262728293031323334353637383940414243interface SpeedController&#123; //abstract methods fun accelerate() fun decelerate() // non-abstract method declaration fun getBrandId():String&#123; return &quot;ABC&quot; &#125;&#125;open class Car&#123; var maxSpeed = 30 open fun start()&#123; println(&quot;Car is starting&quot;) &#125;&#125;class MyCar : Car(), SpeedController&#123; override fun start()&#123; println(&quot;MyCar is starting. Brand id is $&#123;getBrandId()&#125;&quot;) &#125; // without this implementation, you will receive an error &quot;speedController.kt:19:1: error: class &#x27;MyCar&#x27; is not abstract and does not implement abstract member public abstract fun accelerate(): Unit defined in SpeedController&quot; override fun accelerate()&#123; println(&quot;Accelerate&quot;) &#125; override fun decelerate()&#123; println(&quot;Decelerate&quot;) &#125;&#125;fun main()&#123; var car = Car() car.start() var myCar = MyCar() myCar.maxSpeed = 240 println(myCar.maxSpeed) myCar.start()&#125; Function vs Method Function is a piece of code that is called by name that can pass data to operate on Method is a piece of code that is called by name that is associated with an object In the most of time, they refer to the same thing. In general, methods are functions that belong to a class but not all functions are methods 1.YouTube - Day 02: Kotlin Language Fundamentals &amp; Activity Life Cycle ↩","categories":[{"name":"Android Development","slug":"Android-Development","permalink":"http://hexuanweng.github.io/categories/Android-Development/"}],"tags":[{"name":"video course","slug":"video-course","permalink":"http://hexuanweng.github.io/tags/video-course/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://hexuanweng.github.io/tags/Kotlin/"}]},{"title":"LC513 - Find Bottom Left Tree Value","slug":"LC513FindBottomLeftTreeValue","date":"2022-06-21T22:58:37.000Z","updated":"2022-06-21T22:58:37.000Z","comments":true,"path":"2022/06/22/LC513FindBottomLeftTreeValue/","permalink":"http://hexuanweng.github.io/2022/06/22/LC513FindBottomLeftTreeValue/","excerpt":"","text":"DescriptionGiven the root of a binary tree, return the leftmost value in the last row of the tree. Example 1: Input: root &#x3D; [2,1,3]Output: 1 Example 2: Input: root &#x3D; [1,2,3,4,null,5,6,null,null,7]Output: 7 Constraints:The number of nodes in the tree is in the range [1, 104].-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1 SolutionBFS Traverse the tree from left to right, level by level Save the first node of each layer The answer saved by traversing to the bottom layer is the value in the lower left corner of the tree 12345678910111213141516171819202122232425# O(nm) time | O(n) space# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findBottomLeftValue(self, root: Optional[TreeNode]) -&gt; int: if root is None: return queue = [root] ans = 0 while queue: level_len = len(queue) for i in range(level_len): pop_node = queue.pop(0) if i == 0: ans = pop_node.val if pop_node.left: queue.append(pop_node.left) if pop_node.right: queue.append(pop_node.right) return ans Traverse the tree from right to left, level by level The last node traversed is the leftmost value of the tree 123456789101112131415161718192021222324252627# O(n) time | O(n) space# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findBottomLeftValue(self, root: Optional[TreeNode]) -&gt; int: if root is None: return queue = [root] ans = 0 while queue: pop_node = queue.pop(0) ans = pop_node.val if pop_node.right: queue.append(pop_node.right) if pop_node.left: queue.append(pop_node.left) return ans#Runtime: 41 ms, faster than 97.73% of Python3 online submissions for Find Bottom Left Tree Value.#Memory Usage: 16.3 MB, less than 62.72% of Python3 online submissions for Find Bottom Left Tree Value. 1.513. Find Bottom Left Tree Value ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"LC528 - Random Pick With Weight","slug":"LC528RandomPickwithWeight","date":"2022-06-21T05:13:52.000Z","updated":"2022-06-21T05:13:52.000Z","comments":true,"path":"2022/06/21/LC528RandomPickwithWeight/","permalink":"http://hexuanweng.github.io/2022/06/21/LC528RandomPickwithWeight/","excerpt":"","text":"DescriptionYou are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] &#x2F; sum(w).For example, if w &#x3D; [1, 3], the probability of picking index 0 is 1 &#x2F; (1 + 3) &#x3D; 0.25 (i.e., 25%), and the probability of picking index 1 is 3 &#x2F; (1 + 3) &#x3D; 0.75 (i.e., 75%). 123456789Example 1:Input[&quot;Solution&quot;,&quot;pickIndex&quot;][[[1]],[]]Output[null,0]ExplanationSolution solution = new Solution([1]);solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w. 12345678910111213141516171819202122Example 2:Input[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;][[[1,3]],[],[],[],[],[]]Output[null,1,1,1,1,0]ExplanationSolution solution = new Solution([1, 3]);solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.solution.pickIndex(); // return 1solution.pickIndex(); // return 1solution.pickIndex(); // return 1solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.Since this is a randomization problem, multiple answers are allowed.All of the following outputs can be considered correct:[null,1,1,1,1,0][null,1,1,1,1,1][null,1,1,1,0,0][null,1,1,1,0,1][null,1,0,1,0,0]......and so on. Constraints: 1 &lt;&#x3D; w.length &lt;&#x3D; 1041 &lt;&#x3D; w[i] &lt;&#x3D; 105pickIndex will be called at most 104 times. Solution Selected by weight, here I am directly calling the random.randInt() function of Python. But this will only generate random numbers, not selected by weight. We can record the prefix sum, which is actually the sum of all numbers. For example, the prefix sum of [1,3] is [1,4]. That is, if a random number of [1,4] is generated at this time, 1 corresponds to 1, and the random number 2,3,4 corresponds to the prefix and 4, which just satisfies the weight of 1:3. And for w &#x3D; [a,b,c,d] corresponding prefix and ws &#x3D; [a,a+b,a+b+c,a+b+c+d] we can directly generate 0 to a+b+c +d-1 random number. 12345678910111213141516171819202122# O(n) time | O(n) spaceimport randomclass Solution: def __init__(self, w: List[int]): self.summ = [0] for i in range(len(w)): self.summ.append(self.summ[-1]+w[i]) def pickIndex(self) -&gt; int: val = random.randint(1, self.summ[-1]) idx = 0 for i, v in enumerate(self.summ): if v &gt;= val: idx = i -1 break return idx# Your Solution object will be instantiated and called as such:# obj = Solution(w)# param_1 = obj.pickIndex() Bisect Library1234567891011121314#import the moduleimport bisect#given sorted list of numbersnums = [1,3,5,7,10,25,49,55]#given element to be inserted into the listele = 26#get index where to insert the elementidx = bisect.bisect_left(nums, ele)#print the indexprint(f&quot;Insert element &#123;ele&#125; at index &#123;idx&#125; in nums list to maintain sorted order.&quot;) 1234567891011121314151617# O(n) time | O(n) spaceclass Solution: def __init__(self, w: List[int]): self.summ = [0] for i in w: self.summ.append(self.summ[-1]+i) print(self.summ) def pickIndex(self) -&gt; int: num = random.randint(1, self.summ[-1]) idx = bisect.bisect_left(self.summ, num) return idx-1# Your Solution object will be instantiated and called as such:# obj = Solution(w)# param_1 = obj.pickIndex() 1.528. Random Pick with Weight ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"}]},{"title":"Android Development（Kotlin）- First Android App","slug":"AndroidDevelopment-Kotlin","date":"2022-06-20T13:07:15.000Z","updated":"2022-06-20T13:07:15.000Z","comments":true,"path":"2022/06/20/AndroidDevelopment-Kotlin/","permalink":"http://hexuanweng.github.io/2022/06/20/AndroidDevelopment-Kotlin/","excerpt":"","text":"Day1: Build Your First Android AppFolder Structure of an Adroid App AndroidMainfest.xml Contains information that a device needs to run the app An intermediate between android os and our application 12345678910// intent-filter: launch activity -&gt; Launch MainActivity activity first&lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; contains the package details of the application: package=&quot;com.example.kotlinexe1&quot; can add permissions deal with the rest api: we need to provide permission to use the internet connection Java folder contains all the source code files we created source code test files Jave (generated)android studio will generate lots of classes for us and they will be stored in this folder Kotlin language has created on top of Java language and Java library. Kotline is the more mordern version of Java, so that they haven’t changed the folder name to Kotlin res folder contains all non-code resources, does not contain Kotlin files but all other resources drawable: contains all the images (all the format) layout: contains all the xml layout files activity_main.xml is the view MainActivity.kt is the controller file of that view mipmap: contains icon images with all different size values: contains xml files to hold different default values of the project defined colors defined strings themes sub folder: contain details about the theme of the project new themes xml files inside this themes folder Gradle is a automated build system no need to worry about the different configurations, different libraries. build.gradle: app level gradle file, whenever we add a new plugin to the project, we need to define it here 1234plugins &#123; id &#x27;com.android.application&#x27; id &#x27;org.jetbrains.kotlin.android&#x27;&#125; app level gradle filem, we need to add dependencies here 12345678910dependencies &#123; implementation &#x27;androidx.core:core-ktx:1.7.0&#x27; implementation &#x27;androidx.appcompat:appcompat:1.3.0&#x27; implementation &#x27;com.google.android.material:material:1.4.0&#x27; implementation &#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27; testImplementation &#x27;junit:junit:4.13.2&#x27; androidTestImplementation &#x27;androidx.test.ext:junit:1.1.3&#x27; androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;&#125; Build Your First Android Appactivity_main.xml activity_main.xml code mode split mode design mode 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; Layout type constraint layout linear layout box layout UI Layout Validation provided many different screen size MainActivity.ktMainActivity.kt is the layout controller class of the activity_main.xml layout The activity_main.xml file has connected to the class through this setContentView function In Android, onCreate function is called when the activity is first created super.onCreate(savedInstanceState) provides us the bundle containing the activities previously frozen state if there was one 123456789101112131415161718192021222324package com.example.kotlinexe1import androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewclass MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val greetingTextView = findViewById&lt;TextView&gt;(R.id.txt_hello) val inputField = findViewById&lt;EditText&gt;(R.id.txt_name) val submitButton = findViewById&lt;Button&gt;(R.id.btn_submit) submitButton.setOnClickListener()&#123; val enteredName = inputField.text.toString() val message = &quot;Welcome $enteredName!&quot; greetingTextView.text = message &#125; &#125;&#125; Toast.makeText(context: Context!, text: CharSequence!) for the context, we can provide either application context or activity context. applicaton context: Toast.makeText(*applicationContext*) activity context: Toast.makeText(this@MainActivity, &quot;Please enter your name!&quot;, Toast.*LENGTH_SHORT*).show() 💡 Difference: They are both instances of context class but the application context is tied to the life cycle of entire application, while the activity context is tied to the life cycle of an activity. 💡 A parameter is the variable listed inside the parenthesis in the function definition An argument is the value that is sent to the function when it is called 1234567891011121314151617181920212223242526272829303132333435package com.example.kotlinexe1import androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.view.View.VISIBLEimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport android.widget.Toastclass MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val greetingTextView = findViewById&lt;TextView&gt;(R.id.txt_hello) val inputField = findViewById&lt;EditText&gt;(R.id.txt_name) val submitButton = findViewById&lt;Button&gt;(R.id.btn_submit) val offersButton = findViewById&lt;Button&gt;(R.id.btn_viewoffers) submitButton.setOnClickListener()&#123; val enteredName = inputField.text.toString() if (enteredName == &quot;&quot;)&#123; greetingTextView.text = &quot;Welcome!&quot; offersButton Toast.makeText(this@MainActivity, &quot;Please enter your name!&quot;, Toast.LENGTH_SHORT).show() &#125;else&#123; val message = &quot;Welcome $enteredName!&quot; greetingTextView.text = message inputField.text.clear() offersButton.visibility = VISIBLE &#125; &#125; &#125;&#125; navigate to next activity 12345offersButton.setOnClickListener()&#123; // current activity, next activity val intent = Intent(this, MainActivity2::class.java) startActivity(intent)&#125; IntentIn general, intents are used to move between some android component like (activity, service, broadcast receivers …etc) some time you need to pass some value between these components so you need to use putextra in the sender component and getextra in the receiver for example : in the sender : 123val intent = Intent(this, MainActivity2::class.java)intent.putExtra(&quot;USER&quot;, enteredName) // name, valuestartActivity(intent) in the reciver: 1val userName = intent.getStringExtra(&quot;USER&quot;) note that you need to pass the same key to retrieve your value 1.YouTube - Day 01: Build Your First Android App ↩","categories":[{"name":"Android Development","slug":"Android-Development","permalink":"http://hexuanweng.github.io/categories/Android-Development/"}],"tags":[{"name":"video course","slug":"video-course","permalink":"http://hexuanweng.github.io/tags/video-course/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://hexuanweng.github.io/tags/Kotlin/"}]},{"title":"LC1893 - Check if All the Integers in a Range Are Covered","slug":"LC1893CheckifAlltheIntegersinaRangeAreCovered","date":"2022-06-20T12:02:02.000Z","updated":"2022-06-20T12:02:02.000Z","comments":true,"path":"2022/06/20/LC1893CheckifAlltheIntegersinaRangeAreCovered/","permalink":"http://hexuanweng.github.io/2022/06/20/LC1893CheckifAlltheIntegersinaRangeAreCovered/","excerpt":"","text":"DescriptionYou are given a 2D integer array ranges and two integers left and right. Each ranges[i] &#x3D; [starti, endi] represents an inclusive interval between starti and endi.Return true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise.An integer x is covered by an interval ranges[i] &#x3D; [starti, endi] if starti &lt;&#x3D; x &lt;&#x3D; endi. Example 1:Input: ranges &#x3D; [[1,2],[3,4],[5,6]], left &#x3D; 2, right &#x3D; 5Output: trueExplanation: Every integer between 2 and 5 is covered: 2 is covered by the first range. 3 and 4 are covered by the second range. 5 is covered by the third range. Example 2:Input: ranges &#x3D; [[1,10],[10,20]], left &#x3D; 21, right &#x3D; 21Output: falseExplanation: 21 is not covered by any range. Constraints:1 &lt;&#x3D; ranges.length &lt;&#x3D; 501 &lt;&#x3D; starti &lt;&#x3D; endi &lt;&#x3D; 501 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; 50 SolutionsBrute ForceStore all the numbers that appear in ranges in the set of nums, and then traverse the range from left to right, if the numbers are all in nums, return True, if there are numbers that are not included, return False 1234567891011121314# O(n) time | O(n) spaceclass Solution: def isCovered(self, ranges: List[List[int]], left: int, right: int) -&gt; bool: nums = set() for start, end in ranges: for i in range(start, end+1): if i not in nums: nums.add(i) for i in range(left, right+1): if i not in nums: return False return True optimized version 123456789101112# O(n) time | O(1) spaceclass Solution: def isCovered(self, ranges: List[List[int]], left: int, right: int) -&gt; bool: for i in range(left, right+1): flag = 0 for start, end in ranges: if start &lt;= i &lt;= end: flag = 1 if flag == 0: return False return True Difference ArrayTraverse ranges, starting from ranges[0] to calculate the covered changes. 1234567891011121314151617181920# O(n) time | O(n) timeclass Solution: def isCovered(self, ranges: List[List[int]], left: int, right: int) -&gt; bool: diff = [0] * 52 # get difference array for start, end in ranges: diff[start] += 1 diff[end+1] -=1 # prefix sum for i in range(1, 52): diff[i] += diff[i-1] for i in range(left, right+1): if diff[i] == 0: return False return True# 执行用时：24 ms, 在所有 Python3 提交中击败了98.94%的用户# 内存消耗：14.7 MB, 在所有 Python3 提交中击败了99.29%的用户 1.1893. Check if All the Integers in a Range Are Covered ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Difference Array","slug":"Difference-Array","permalink":"http://hexuanweng.github.io/tags/Difference-Array/"}]},{"title":"LC508 - Most Frequent SubtreeSum","slug":"LC508MostFrequentSubtreeSum","date":"2022-06-19T12:15:46.000Z","updated":"2022-06-19T12:15:46.000Z","comments":true,"path":"2022/06/19/LC508MostFrequentSubtreeSum/","permalink":"http://hexuanweng.github.io/2022/06/19/LC508MostFrequentSubtreeSum/","excerpt":"","text":"DescriptionGiven the root of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order.The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). Example 1: Input: root &#x3D; [5,2,-3]Output: [2,-3,4] Example 2: Input: root &#x3D; [5,2,-5]Output: [2] Constraints:The number of nodes in the tree is in the range [1, 104].-105 &lt;&#x3D; Node.val &lt;&#x3D; 105 SolutionThe case means: example 1: Input [5,2,-3], then the subtree sum is 5 + 2 - 3 &#x3D; 4, subtree 2, subtree -3, so the number of occurrences of each is equal, and directly returns [2,- 3,4]. example 2: Input [5,2,-5], subtree 2, subtree-5, and subtree and 5 + 2 - 5 &#x3D; 2, so the maximum number of occurrences is 2. Traverse Order: left -&gt; right -&gt; root. The value of the update root is the sum of the left subtree and right subtree. Store the number of occurrences of the sum in the dictionary Use max() to find the number with the largest value in the dictionary, traverse the dictionary, store the value and the key of the largest number in ans, and return ans 1234567891011121314151617181920212223242526272829303132333435# O(n) time | O(n) space# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findFrequentTreeSum(self, root: TreeNode) -&gt; List[int]: summ = &#123;&#125; ans = [] self.dfs(root, summ) maxVal = max(summ.values()) for key, val in summ.items(): if val == maxVal: ans.append(key) return ans def dfs(self, root, summ): if root is None: return self.dfs(root.left, summ) self.dfs(root.right, summ) if root.left: root.val += root.left.val if root.right: root.val += root.right.val if root.val not in summ: summ[root.val] =1 else: summ[root.val]+=1 1.508. Most Frequent Subtree Sum ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Depth First Search","slug":"Depth-First-Search","permalink":"http://hexuanweng.github.io/tags/Depth-First-Search/"}]},{"title":"LC1089 - Duplicate Zeros","slug":"LC1089DuplicateZeros","date":"2022-06-16T23:56:42.000Z","updated":"2022-06-16T23:56:42.000Z","comments":true,"path":"2022/06/17/LC1089DuplicateZeros/","permalink":"http://hexuanweng.github.io/2022/06/17/LC1089DuplicateZeros/","excerpt":"","text":"DescriptionGiven a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything. Example 1: Input: arr &#x3D; [1,0,2,3,0,4,5,0]Output: [1,0,0,2,3,0,0,4]Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]Example 2: Input: arr &#x3D; [1,2,3]Output: [1,2,3]Explanation: After calling your function, the input array is modified to: [1,2,3] Constraints: 1 &lt;&#x3D; arr.length &lt;&#x3D; 1040 &lt;&#x3D; arr[i] &lt;&#x3D; 9 SolutionSimulation A combination of python’s built-in functions pop and insert is used. The time complexity of insert is O(n) 12345678910111213141516171819202122232425262728Lists: ComplexityOperation | Example | Class | Notes--------------+--------------+---------------+-------------------------------Index | l[i] | O(1) |Store | l[i] = 0 | O(1) |Length | len(l) | O(1) |Append | l.append(5) | O(1) |Clear | l.clear() | O(1) | similar to l = []Slice | l[a:b] | O(b-a) | l[1:5]:O(l)/l[:]:O(len(l)-0)=O(N)Extend | l.extend(...)| O(len(...)) | depends only on len of extensionConstruction | list(...) | len(...) | depends on lenghth of argumentcheck ==, != | l1 == l2 | O(N) |Insert | l[a:b] = ... | O(N) |Delete | del l[i] | O(N) |Remove | l.remove(...)| O(N) |Containment | x in/not in l| O(N) | searches listCopy | l.copy() | O(N) | Same as l[:] which is O(N)Pop | l.pop(...) | O(N) |Pop | l.pop() | O(1) | same as l.pop(-1), popping at endExtreme value | min(l)/max(l)| O(N) |Reverse | l.reverse() | O(N) |Iteration | for v in l: | O(N) |Sort | l.sort() | O(N Log N) | key/reverse doesn&#x27;t change thisMultiply | k*l | O(k N) | 5*l is O(N): len(l)*l is O(N**2) 12345678910111213# O(n^2) time | O(1) spaceclass Solution: def duplicateZeros(self, arr: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify arr in-place instead. &quot;&quot;&quot; idx = 0 while idx &lt; len(arr): if arr[idx] == 0: arr.pop() arr.insert(idx, 0) idx+=1 idx+=1 Two PointersTraverse the number of zeros and the end position of the data,Imagine that each zero is pushed onto the stack twice, and the traversal ends when the stack is as long as the array. Pops elements from the top of the stack in order. A pointer left represents the data position (the top of the stack), and a pointer represents the write position (the current write position of the original array) 1234567891011121314151617181920212223242526272829# O(n) time | O(1) spaceclass Solution: def duplicateZeros(self, arr: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify arr in-place instead. &quot;&quot;&quot; left = -1 top_idx = 0 while top_idx &lt; len(arr): left+=1 if arr[left]: top_idx+=1 else: top_idx+=2 right = len(arr)-1 if top_idx == len(arr) +1: arr[right] = 0 right -=1 left -=1 while right &gt;=0: arr[right] = arr[left] right -=1 if arr[left] == 0: arr[right] = arr[left] right -=1 left-=1 1.1089. Duplicate Zeros ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Simulation","slug":"Simulation","permalink":"http://hexuanweng.github.io/tags/Simulation/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://hexuanweng.github.io/tags/Two-Pointers/"}]},{"title":"LC303 - Range Sum Quey - Immutable","slug":"LC303RangeSumQuey-Immutable","date":"2022-06-16T01:38:35.000Z","updated":"2022-06-16T01:38:35.000Z","comments":true,"path":"2022/06/16/LC303RangeSumQuey-Immutable/","permalink":"http://hexuanweng.github.io/2022/06/16/LC303RangeSumQuey-Immutable/","excerpt":"","text":"DescriptionGiven an integer array nums, handle multiple queries of the following type: Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;&#x3D; right.Implement the NumArray class: NumArray(int[] nums) Initializes the object with the integer array nums.int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + … + nums[right]). Example 1: Input[“NumArray”, “sumRange”, “sumRange”, “sumRange”][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]Output[null, 1, -1, -3] ExplanationNumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); &#x2F;&#x2F; return (-2) + 0 + 3 &#x3D; 1numArray.sumRange(2, 5); &#x2F;&#x2F; return 3 + (-5) + 2 + (-1) &#x3D; -1numArray.sumRange(0, 5); &#x2F;&#x2F; return (-2) + 0 + 3 + (-5) + 2 + (-1) &#x3D; -3 Constraints: 1 &lt;&#x3D; nums.length &lt;&#x3D; 104-105 &lt;&#x3D; nums[i] &lt;&#x3D; 1050 &lt;&#x3D; left &lt;&#x3D; right &lt; nums.lengthAt most 104 calls will be made to sumRange. SolutionBasic Prefix sum problemMany other prefix sum problems can be solved according to this logic 12345678910111213class NumArray: def __init__(self, nums: List[int]): self.summ = [0] for i in nums: self.summ.append(self.summ[-1] + i) def sumRange(self, left: int, right: int) -&gt; int: return self.summ[right+1] - self.summ[left]# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(left,right) 1.303. Range Sum Query - Immutable ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"}]},{"title":"LC1588 - Sum of All Odd Length Subarrays","slug":"LC1588SumofAllOddLengthSubarrays","date":"2022-06-16T01:22:22.000Z","updated":"2022-06-16T01:22:22.000Z","comments":true,"path":"2022/06/16/LC1588SumofAllOddLengthSubarrays/","permalink":"http://hexuanweng.github.io/2022/06/16/LC1588SumofAllOddLengthSubarrays/","excerpt":"","text":"DescriptionGiven an array of positive integers arr, return the sum of all possible odd-length subarrays of arr. A subarray is a contiguous subsequence of the array. Example 1: Input: arr &#x3D; [1,4,2,5,3]Output: 58Explanation: The odd-length subarrays of arr and their sums are:[1] &#x3D; 1[4] &#x3D; 4[2] &#x3D; 2[5] &#x3D; 5[3] &#x3D; 3[1,4,2] &#x3D; 7[4,2,5] &#x3D; 11[2,5,3] &#x3D; 10[1,4,2,5,3] &#x3D; 15If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 &#x3D; 58Example 2: Input: arr &#x3D; [1,2]Output: 3Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.Example 3: Input: arr &#x3D; [10,11,12]Output: 66 Constraints: 1 &lt;&#x3D; arr.length &lt;&#x3D; 1001 &lt;&#x3D; arr[i] &lt;&#x3D; 1000 SolutionBrute Force12345678910111213# O(n^3) time | O(1) spaceclass Solution: def sumOddLengthSubarrays(self, arr: List[int]) -&gt; int: result = 0 for odd in range(1, len(arr)+1, 2): cur = 0 while cur + odd &lt;= len(arr): summ = sum(arr[cur:cur+odd]) cur+=1 result += summ return result Prefix Sum Prefix sum, num[i] represents the sum of 0 ~ i numbers, then num[i] &#x3D; num[i] + sum(0 ~ i - 1) Therefore, you only need to find the odd length (denoted as i) that is less than the length of the arr array, and then calculate the difference between the lengths num[j + i] - num[j] in turn. 1234567891011121314# O(n^2) time | O(n) spaceclass Solution: def sumOddLengthSubarrays(self, arr: List[int]) -&gt; int: summ = [0] res = 0 for i in arr: summ.append(summ[-1]+i) for odd in range(1, len(arr)+1, 2): left = 0 while left+odd &lt; len(summ): res+= summ[left+odd]-summ[left] left+=1 return res 1.532. K-diff Pairs in an Array ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"}]},{"title":"LC532 - K-Diff Pairs in an Array","slug":"LC532K-diffPairsinanArray","date":"2022-06-16T00:43:34.000Z","updated":"2022-06-16T00:43:34.000Z","comments":true,"path":"2022/06/16/LC532K-diffPairsinanArray/","permalink":"http://hexuanweng.github.io/2022/06/16/LC532K-diffPairsinanArray/","excerpt":"","text":"DescriptionGiven an array of integers nums and an integer k, return the number of unique k-diff pairs in the array. A k-diff pair is an integer pair (nums[i], nums[j]), where the following are true: 0 &lt;&#x3D; i, j &lt; nums.lengthi !&#x3D; jnums[i] - nums[j] &#x3D;&#x3D; kNotice that |val| denotes the absolute value of val. Example 1: Input: nums &#x3D; [3,1,4,1,5], k &#x3D; 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.Example 2: Input: nums &#x3D; [1,2,3,4,5], k &#x3D; 1Output: 4Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).Example 3: Input: nums &#x3D; [1,3,1,5,4], k &#x3D; 0Output: 1Explanation: There is one 0-diff pair in the array, (1, 1). Constraints: 1 &lt;&#x3D; nums.length &lt;&#x3D; 104-107 &lt;&#x3D; nums[i] &lt;&#x3D; 1070 &lt;&#x3D; k &lt;&#x3D; 107 Solutions Sort the nums list Then, maintain two pointers i, j, and guarantee i &lt; j &lt; n, if nums[j] = nums[i] + k is counted in the answer 123456789101112131415161718# O(nlogn) time | O(nlogn) spaceclass Solution: def findPairs(self, nums: List[int], k: int) -&gt; int: ans = set() l, r = 0, 0 nums.sort() while r &lt; len(nums): left, right = nums[l], nums[r] if right - left == k: if l &lt; r and (left, right) not in ans: ans.add((left, right)) r+=1 elif right-left &lt; k: r +=1 elif right - left &gt; k: l +=1 return len(ans) 1.532. K-diff Pairs in an Array ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Sorting","slug":"Sorting","permalink":"http://hexuanweng.github.io/tags/Sorting/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://hexuanweng.github.io/tags/Two-Pointers/"}]},{"title":"LC498 - Diagonal Traverse","slug":"LC498DiagonalTraverse","date":"2022-06-14T02:16:08.000Z","updated":"2022-06-14T02:16:08.000Z","comments":true,"path":"2022/06/14/LC498DiagonalTraverse/","permalink":"http://hexuanweng.github.io/2022/06/14/LC498DiagonalTraverse/","excerpt":"","text":"DescriptionGiven an m x n matrix mat, return an array of all the elements of the array in a diagonal order. Example 1: Input: mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]Output: [1,2,4,7,5,3,6,8,9]Example 2: Input: mat &#x3D; [[1,2],[3,4]]Output: [1,2,3,4] Constraints: m &#x3D;&#x3D; mat.lengthn &#x3D;&#x3D; mat[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 1041 &lt;&#x3D; m * n &lt;&#x3D; 104-105 &lt;&#x3D; mat[i][j] &lt;&#x3D; 105 SolutionAssuming n &#x3D; row, m &#x3D; column, the current point is (i,j), since each traversal is on the line i+j&#x3D;z, so write (i,z-i), z is from 0 to m+n-2 Use i to traverse, the point of each traversal is (i, z-i), there are two inequalities0&lt;&#x3D;i&lt;&#x3D;n-10&lt;&#x3D;z-i&lt;&#x3D;m-1, that is, z-m+1&lt;&#x3D;i&lt;&#x3D;z So the lower bound is: max(0,z-m+1)The upper bound is: min(n-1,z) Then traverse from the upper bound to the lower bound, and from the next to the upper bound, and both the upper and lower bounds can be obtained. 12345678910111213141516171819# O(nm) time | O(n) spaceclass Solution: def findDiagonalOrder(self, mat: List[List[int]]) -&gt; List[int]: row = len(mat) col = len(mat[0]) # 0: bottom to top, 1: top to bottom direction = 0 res = [] for line in range(row+col-1): if direction: for item in range(max(0, line - col +1), min(row-1, line)+1): res.append(mat[item][line-item]) direction = 0 else: for item in range(min(row-1, line), max(0, line-col+1)-1, -1): res.append(mat[item][line-item]) direction = 1 return res 1.498. Diagonal Traverse ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Simulation","slug":"Simulation","permalink":"http://hexuanweng.github.io/tags/Simulation/"},{"name":"Math","slug":"Math","permalink":"http://hexuanweng.github.io/tags/Math/"}]},{"title":"LC406 - Queue Reconstruction by Height","slug":"LC406QueueReconstructionbyHeight","date":"2022-06-14T00:58:21.000Z","updated":"2022-06-14T00:58:21.000Z","comments":true,"path":"2022/06/14/LC406QueueReconstructionbyHeight/","permalink":"http://hexuanweng.github.io/2022/06/14/LC406QueueReconstructionbyHeight/","excerpt":"","text":"DescriptionYou are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] &#x3D; [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi. Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] &#x3D; [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue). Example 1: Input: people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]Explanation:Person 0 has height 5 with no other people taller or the same height in front.Person 1 has height 7 with no other people taller or the same height in front.Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.Person 3 has height 6 with one person taller or the same height in front, which is person 1.Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.Person 5 has height 7 with one person taller or the same height in front, which is person 1.Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.Example 2: Input: people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] Constraints: 1 &lt;&#x3D; people.length &lt;&#x3D; 20000 &lt;&#x3D; hi &lt;&#x3D; 1060 &lt;&#x3D; ki &lt; people.lengthIt is guaranteed that the queue can be reconstructed. Solution Sort people by height in descending order, same height by location in ascending order Inserted by position value from big to small, because the big one is inserted first, the current position is the position of the inserted column. 12345678910111213141516171819# O(n^2) time | O(logn) spaceclass Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: people.sort(key=lambda x:(-x[0], x[1])) res = [] for h, idx in people: res.insert(idx, (h, idx)) return res## Another way of codingclass Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: people.sort(key = lambda x: (-x[0], x[1])) res = [] for h, p in people: res[p:p] = [[h, p]] return res NoteTime complexity: O(n^2), where n is the length of people, requires O(nlogn) sorting, and then takes O(n^2) time to traverse each person into the queue 12345678people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]ans = []for i in people: ans[i[1]:i[1]] = [i]print(ans)## insertans[i[1]:i[1]] = [i] == ans.insert(i[1], i) 1.406. Queue Reconstruction by Height ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"Sorting","slug":"Sorting","permalink":"http://hexuanweng.github.io/tags/Sorting/"},{"name":"Greedy","slug":"Greedy","permalink":"http://hexuanweng.github.io/tags/Greedy/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"}]},{"title":"LC1051 - Height Checker","slug":"LC1051HeightChecker","date":"2022-06-14T00:06:36.000Z","updated":"2022-06-14T00:06:36.000Z","comments":true,"path":"2022/06/14/LC1051HeightChecker/","permalink":"http://hexuanweng.github.io/2022/06/14/LC1051HeightChecker/","excerpt":"","text":"DescriptionA school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line. You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed). Return the number of indices where heights[i] !&#x3D; expected[i]. Example 1: Input: heights &#x3D; [1,1,4,2,1,3]Output: 3Explanation:heights: [1,1,4,2,1,3]expected: [1,1,1,2,3,4]Indices 2, 4, and 5 do not match.Example 2: Input: heights &#x3D; [5,1,2,3,4]Output: 5Explanation:heights: [5,1,2,3,4]expected: [1,2,3,4,5]All indices do not match.Example 3: Input: heights &#x3D; [1,2,3,4,5]Output: 0Explanation:heights: [1,2,3,4,5]expected: [1,2,3,4,5]All indices match. Constraints: 1 &lt;&#x3D; heights.length &lt;&#x3D; 1001 &lt;&#x3D; heights[i] &lt;&#x3D; 100 Solution Sort the array heights and store it in the variable expected Count the number of heights[i] ≠ expected[i] 123456789#O(nlogn) time | O(1) spaceclass Solution: def heightChecker(self, heights: List[int]) -&gt; int: expected = sorted(heights) cnt =0 for i in range(len(heights)): if expected[i] != heights[i]: cnt+=1 return cnt 1.1051. Height Checker ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Sorting","slug":"Sorting","permalink":"http://hexuanweng.github.io/tags/Sorting/"}]},{"title":"LC890 - Find and Replace Pattern","slug":"LC890FindandReplacePattern","date":"2022-06-12T02:00:21.000Z","updated":"2022-06-12T02:00:21.000Z","comments":true,"path":"2022/06/12/LC890FindandReplacePattern/","permalink":"http://hexuanweng.github.io/2022/06/12/LC890FindandReplacePattern/","excerpt":"","text":"DescriptionGiven a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter. Example 1: Input: words &#x3D; [“abc”,”deq”,”mee”,”aqq”,”dkd”,”ccc”], pattern &#x3D; “abb”Output: [“mee”,”aqq”]Explanation: “mee” matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, …}.“ccc” does not match the pattern because {a -&gt; c, b -&gt; c, …} is not a permutation, since a and b map to the same letter.Example 2: Input: words &#x3D; [“a”,”b”,”c”], pattern &#x3D; “a”Output: [“a”,”b”,”c”] Constraints: 1 &lt;&#x3D; pattern.length &lt;&#x3D; 201 &lt;&#x3D; words.length &lt;&#x3D; 50words[i].length &#x3D;&#x3D; pattern.lengthpattern and words[i] are lowercase English letters. SolutionAccording to the topic of the use rule, traverse each word, check all the words existing in each word one by one, and determine whether the mapping is satisfied. 123456789101112131415161718192021222324# O(nm) time | O(n) spaceclass Solution: def findAndReplacePattern(self, words: List[str], pattern: str) -&gt; List[str]: res = [] for word in words: dic_pattern = &#123;&#125; dic_words = &#123;&#125; for i in range(len(word)): if pattern[i] not in dic_pattern: dic_pattern[pattern[i]] = word[i] else: if dic_pattern[pattern[i]] != word[i]: break if word[i] not in dic_words: dic_words[word[i]] = pattern[i] else: if dic_words[word[i]] != pattern[i]: break if i == len(word)-1: res.append(word) return res 1.890. Find and Replace Pattern ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Hashmap","slug":"Hashmap","permalink":"http://hexuanweng.github.io/tags/Hashmap/"}]},{"title":"LC798 - Smallest Rotation With Highest Score","slug":"LC798SmallestRotationwithHighestScore","date":"2022-06-10T11:55:14.000Z","updated":"2022-06-10T11:55:14.000Z","comments":true,"path":"2022/06/10/LC798SmallestRotationwithHighestScore/","permalink":"http://hexuanweng.github.io/2022/06/10/LC798SmallestRotationwithHighestScore/","excerpt":"","text":"DiscriptionYou are given an array nums. You can rotate it by a non-negative integer k so that the array becomes [nums[k], nums[k + 1], … nums[nums.length - 1], nums[0], nums[1], …, nums[k-1]]. Afterward, any entries that are less than or equal to their index are worth one point. For example, if we have nums &#x3D; [2,4,1,3,0], and we rotate by k &#x3D; 2, it becomes [1,3,0,2,4]. This is worth 3 points because 1 &gt; 0 [no points], 3 &gt; 1 [no points], 0 &lt;&#x3D; 2 [one point], 2 &lt;&#x3D; 3 [one point], 4 &lt;&#x3D; 4 [one point].Return the rotation index k that corresponds to the highest score we can achieve if we rotated nums by it. If there are multiple answers, return the smallest such index k. Example 1: Input: nums &#x3D; [2,3,1,4,0]Output: 3Explanation: Scores for each k are listed below:k &#x3D; 0, nums &#x3D; [2,3,1,4,0], score 2k &#x3D; 1, nums &#x3D; [3,1,4,0,2], score 3k &#x3D; 2, nums &#x3D; [1,4,0,2,3], score 3k &#x3D; 3, nums &#x3D; [4,0,2,3,1], score 4k &#x3D; 4, nums &#x3D; [0,2,3,1,4], score 3So we should choose k &#x3D; 3, which has the highest score.Example 2: Input: nums &#x3D; [1,3,0,2,4]Output: 0Explanation: nums will always have 3 points no matter how it shifts.So we will choose the smallest k, which is 0. Constraints: 1 &lt;&#x3D; nums.length &lt;&#x3D; 1050 &lt;&#x3D; nums[i] &lt; nums.length SolutionA number num, the final and coordinate difference is less than or equal to 0, there is only one range, that is, the coordinates are in [num, n-1], and the time difference between [0, num-1] will obviously be greater than 0. 12345678910Take nums=[2,3,1,4,0] as an example to illustrate i=0,nums[i]=2 To score, it needs to be adjusted to the 2~4 position, and it needs to be adjusted 1~3 steps i=1,nums[i]=3 To score, it needs to be adjusted to the 3~4 position, and it needs to be adjusted for 2~3 steps i=2,nums[i]=1 To score, you need to adjust to 1~4 position, you need to adjust 0~1 and 3~4 steps (3~1) i=3,nums[i]=4 To score, it needs to be adjusted to the 4~4 position, and it needs to be adjusted 4~4 steps i=4,nums[i]=0 To score, you need to adjust to 0~4 position, you need to adjust 0~4 steps To sum up, for each nums[i], the number of arguments k wants to make the upper and lower bounds of the number score: [(i+1)%n,(i+n-nums[i])%n] For i=2, nums[i]=1 is a special case, the upper and lower bounds 3 and 1 can also be calculated by the formula, and 0 and 4 need to be supplemented by themselves Finally, we count the range coverage of k corresponding to each nums[i], k represents the score in a certain coverage times, and the minimum value of k corresponding to the highest score (the most coverage times) is the answer 123456789101112131415161718192021#O(n) time | O(n) spaceclass Solution: def bestRotation(self, nums: List[int]) -&gt; int: diff = [0] * len(nums) for i, v in enumerate(nums): low = (i+1)% len(nums) high = (i - v + len(nums)+1)%len(nums) diff[low] +=1 # start diff[high] -=1 # end+1 if low &gt;= high: diff[0] +=1 current = 0 maxi = 0 idx = 0 for i, v in enumerate(diff): current += v if current&gt;maxi: maxi = current idx = i return idx 1.798. Smallest Rotation with Highest Score ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"hard","slug":"hard","permalink":"http://hexuanweng.github.io/tags/hard/"},{"name":"Difference Array","slug":"Difference-Array","permalink":"http://hexuanweng.github.io/tags/Difference-Array/"}]},{"title":"LC1109 - Corporate Flight Bookings","slug":"LC1109CorporateFlightBookings","date":"2022-06-10T11:41:20.000Z","updated":"2022-06-10T11:41:20.000Z","comments":true,"path":"2022/06/10/LC1109CorporateFlightBookings/","permalink":"http://hexuanweng.github.io/2022/06/10/LC1109CorporateFlightBookings/","excerpt":"","text":"DescriptionThere are n flights that are labeled from 1 to n. You are given an array of flight bookings bookings, where bookings[i] &#x3D; [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range. Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i. Example 1: Input: bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5Output: [10,55,45,25,25]Explanation:Flight labels: 1 2 3 4 5Booking 1 reserved: 10 10Booking 2 reserved: 20 20Booking 3 reserved: 25 25 25 25Total seats: 10 55 45 25 25Hence, answer &#x3D; [10,55,45,25,25]Example 2: Input: bookings &#x3D; [[1,2,10],[2,2,15]], n &#x3D; 2Output: [10,25]Explanation:Flight labels: 1 2Booking 1 reserved: 10 10Booking 2 reserved: 15Total seats: 10 25Hence, answer &#x3D; [10,25] Constraints: 1 &lt;&#x3D; n &lt;&#x3D; 2 * 1041 &lt;&#x3D; bookings.length &lt;&#x3D; 2 * 104bookings[i].length &#x3D;&#x3D; 31 &lt;&#x3D; firsti &lt;&#x3D; lasti &lt;&#x3D; n1 &lt;&#x3D; seatsi &lt;&#x3D; 104 Solution 12345678#前缀和 O(n^2) time | O(1) spaceclass Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -&gt; List[int]: answer = [0] * (n+1) for start, end, value in bookings: for i in range(start, end+1): answer[i] += value return answer[1:] The idea of the difference method: Start index first, accumulate the number of seats At the end of index last+1, subtract the current number of seats Because the flight after the last, there is no current seat When subtracting first, and then adding prefixes, they will actually cancel each other out It is easy to understand how the idea of difference solves this problem by drawing an array. 12345678910111213#O(n) time | O(n) spaceclass Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -&gt; List[int]: diff = [0] * (n+1) for start, end, value in bookings: diff[start] += value if end &lt; n: diff[end+1] -= value for i in range(1, len(diff)): diff[i] += diff[i-1] return diff[1:] 1.1109. Corporate Flight Bookings ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Difference Array","slug":"Difference-Array","permalink":"http://hexuanweng.github.io/tags/Difference-Array/"}]},{"title":"LC560 - Subarray Sum Equals K","slug":"LC560SubarraySumEqualsK","date":"2022-06-10T11:34:52.000Z","updated":"2022-06-10T11:34:52.000Z","comments":true,"path":"2022/06/10/LC560SubarraySumEqualsK/","permalink":"http://hexuanweng.github.io/2022/06/10/LC560SubarraySumEqualsK/","excerpt":"","text":"DescriptionGiven an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. A subarray is a contiguous non-empty sequence of elements within an array. Example 1: Input: nums &#x3D; [1,1,1], k &#x3D; 2Output: 2Example 2: Input: nums &#x3D; [1,2,3], k &#x3D; 3Output: 2 Constraints: 1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000-107 &lt;&#x3D; k &lt;&#x3D; 107 Solution Each element corresponds to a “prefix sum” Traverse the array to find the historical prefix sum of “subtract it &#x3D;&#x3D; k” in the map based on the current “prefix sum” The difference between the current “prefix sum” and the historical prefix sum is a sub-array. If the historical prefix sum occurs c times, it means that the current item finds c sub-arrays and the sum is equal to k. During the traversal process, c is continuously added to count, and finally returns count 12345678910111213# O(n^2) time | O(n) space-- Time Out Exceedclass Solution: def subarraySum(self, nums: List[int], k: int) -&gt; int: presum = [0] for i, v in enumerate(nums): presum.append(presum[-1] + v) cnt = 0 for i in range(len(presum)): for j in range(i+1, len(presum)): if presum[j] - presum[i] == k: cnt+=1 return cnt Prefix Sum + Hash TableWe need to find the interval that satisfies the sum K. At this time, presum is known, and k is also known. We only need to find the number of presum - k intervals to get the number of k intervals. 1234567891011121314151617# O(n) time | O(n) spaceclass Solution: def subarraySum(self, nums: List[int], k: int) -&gt; int: presum = &#123;0:1&#125; cur = 0 res = 0 for i in nums: cur += i if cur - k in presum: res += presum[cur-k] if cur not in presum: presum[cur] = 1 else: presum[cur] += 1 return res 1.560. Subarray Sum Equals K ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Hashmap","slug":"Hashmap","permalink":"http://hexuanweng.github.io/tags/Hashmap/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"}]},{"title":"LC209 - Minimum Size Subarray Sum","slug":"LC209MinimumSizeSubarraySum","date":"2022-06-10T03:34:35.000Z","updated":"2022-06-10T03:34:35.000Z","comments":true,"path":"2022/06/10/LC209MinimumSizeSubarraySum/","permalink":"http://hexuanweng.github.io/2022/06/10/LC209MinimumSizeSubarraySum/","excerpt":"","text":"DescriptionGiven an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, …, numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. Example 1: Input: target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]Output: 2Explanation: The subarray [4,3] has the minimal length under the problem constraint.Example 2: Input: target &#x3D; 4, nums &#x3D; [1,4,4]Output: 1Example 3: Input: target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]Output: 0 Constraints: 1 &lt;&#x3D; target &lt;&#x3D; 1091 &lt;&#x3D; nums.length &lt;&#x3D; 1051 &lt;&#x3D; nums[\\i] &lt;&#x3D; 105 Solution Initialize left&#x3D;right&#x3D;0, and call the index closed interval [left, right] a window. Continuously increase the right pointer to expand the window until the string in the window meets the requirements (satisfies &gt;&#x3D; target). Stop increasing the right, and instead increase the left to shrink the window until the string in the window no longer meets the requirements At the same time, each time left is increased, a round of results must be recorded. Repeat steps until right reaches the end of the string. 12345678910111213141516# O(n) time | O(n) sapceclass Solution: def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int: summ = [0] for i in nums: summ.append(summ[-1]+i) i, j = 0, 1 ans = len(nums)+1 while j &lt; len(summ): if summ[j] - summ[i] &lt; target: j+=1 else: ans = min(ans, j-i) i+=1 return 0 if ans == len(nums)+1 else ans optimize the complexity of space from linear to to constant. 1234567891011121314# O(n) time | O(1) spaceclass Solution: def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int: left, right = 0, 0 res = float(&#x27;inf&#x27;) total = 0 while right &lt; len(nums): total += nums[right] while total &gt;= target: res = min(res, right-left+1) total -= nums[left] left+=1 right +=1 return 0 if res == float(&#x27;inf&#x27;) else res 1.209. Minimum Size Subarray Sum ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://hexuanweng.github.io/tags/Sliding-Window/"}]},{"title":"LC497 - Random Pointin Non-Overlapping Rectangles","slug":"LC497RandomPointinNon-overlappingRectangles","date":"2022-06-10T01:53:32.000Z","updated":"2022-06-10T01:53:32.000Z","comments":true,"path":"2022/06/10/LC497RandomPointinNon-overlappingRectangles/","permalink":"http://hexuanweng.github.io/2022/06/10/LC497RandomPointinNon-overlappingRectangles/","excerpt":"","text":"DescriptionYou are given an array of non-overlapping axis-aligned rectangles rects where rects[i] &#x3D; [ai, bi, xi, yi] indicates that (ai, bi) is the bottom-left corner point of the ith rectangle and (xi, yi) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle. Any integer point inside the space covered by one of the given rectangles should be equally likely to be returned. Note that an integer point is a point that has integer coordinates. Implement the Solution class: Solution(int[][] rects) Initializes the object with the given rectangles rects.int[] pick() Returns a random integer point [u, v] inside the space covered by one of the given rectangles. Example 1: Input[“Solution”, “pick”, “pick”, “pick”, “pick”, “pick”][[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]Output[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]] ExplanationSolution solution &#x3D; new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);solution.pick(); &#x2F;&#x2F; return [1, -2]solution.pick(); &#x2F;&#x2F; return [1, -1]solution.pick(); &#x2F;&#x2F; return [-1, -2]solution.pick(); &#x2F;&#x2F; return [-2, -2]solution.pick(); &#x2F;&#x2F; return [0, 0] Constraints: 1 &lt;&#x3D; rects.length &lt;&#x3D; 100rects[i].length &#x3D;&#x3D; 4-109 &lt;&#x3D; ai &lt; xi &lt;&#x3D; 109-109 &lt;&#x3D; bi &lt; yi &lt;&#x3D; 109xi - ai &lt;&#x3D; 2000yi - bi &lt;&#x3D; 2000All the rectangles do not overlap.At most 104 calls will be made to pick. Solution Calculate prefixes and arrays. The last bit in the prefix sum array stores the total number of coordinate points at this time, so we choose a random number within this range. See which interval the number is in the prefix and array, each interval represents a different rectangle. Since their weights are different, the subscript of each rectangle is selected according to its prefix and the number in the array. As shown in the figure below, the probability of selecting rectangle one is 9&#x2F;37, the probability of selecting rectangle two is 12&#x2F;37, and the probability of selecting square three is 16&#x2F;37. When a rectangle has been selected fairly after the above process is completed, we then randomly return a point in its rectangle according to the method in step disassembly 1234567891011121314151617class Solution: def __init__(self, rects: List[List[int]]): self.rects = rects self.presum = [0] for ai, bi, xi, yi in rects: self.presum.append(self.presum[-1]+(xi-ai+1) * (yi-bi+1)) def pick(self) -&gt; List[int]: val = random.randint(1, self.presum[-1]) idx = bisect.bisect_left(self.presum, val) -1 ai, bi, xi, yi = self.rects[idx] return [random.randint(ai, xi), random.randint(bi, yi)]# Your Solution object will be instantiated and called as such:# obj = Solution(rects)# param_1 = obj.pick() 1.497. Random Point in Non-overlapping Rectangles ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"}]},{"title":"LC1037 - Valid Boomerang","slug":"LC1037ValidBoomerang","date":"2022-06-08T12:56:00.000Z","updated":"2022-06-08T12:56:00.000Z","comments":true,"path":"2022/06/08/LC1037ValidBoomerang/","permalink":"http://hexuanweng.github.io/2022/06/08/LC1037ValidBoomerang/","excerpt":"","text":"DescriptionGiven an array points where points[i] &#x3D; [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang. A boomerang is a set of three points that are all distinct and not in a straight line. Example 1: Input: points &#x3D; [[1,1],[2,3],[3,2]]Output: trueExample 2: Input: points &#x3D; [[1,1],[2,2],[3,3]]Output: false Constraints: points.length &#x3D;&#x3D; 3points[i].length &#x3D;&#x3D; 20 &lt;&#x3D; xi, yi &lt;&#x3D; 100 SolutionFormula: (y2 - y1) * (x3 - x2) !&#x3D; (y3 - y2) * (x2 - x1) 1234class Solution: def isBoomerang(self, points: List[List[int]]) -&gt; bool: (x1, y1), (x2, y2), (x3, y3) = points return (y2 - y1) * (x3 - x2) != (y3 - y2) * (x2 - x1) 1.1037. Valid Boomerang ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Math","slug":"Math","permalink":"http://hexuanweng.github.io/tags/Math/"}]},{"title":"LC475 - Heaters","slug":"LC475Heaters","date":"2022-06-07T13:11:44.000Z","updated":"2022-06-07T13:11:44.000Z","comments":true,"path":"2022/06/07/LC475Heaters/","permalink":"http://hexuanweng.github.io/2022/06/07/LC475Heaters/","excerpt":"","text":"DescriptionWinter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses. Every house can be warmed, as long as the house is within the heater’s warm radius range. Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses. Notice that all the heaters follow your radius standard, and the warm radius will the same. Example 1: Input: houses &#x3D; [1,2,3], heaters &#x3D; [2]Output: 1Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.Example 2: Input: houses &#x3D; [1,2,3,4], heaters &#x3D; [1,4]Output: 1Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.Example 3: Input: houses &#x3D; [1,5], heaters &#x3D; [2]Output: 3 Constraints: 1 &lt;&#x3D; houses.length, heaters.length &lt;&#x3D; 3 * 1041 &lt;&#x3D; houses[i], heaters[i] &lt;&#x3D; 109 Solution This question is to find the minimum heating radius, then the object divided by two is the radius The interval can only be large and not small. The left interval of the dichotomy is 0. When the house and the heater overlap, the interval of the dichotomy is the largest coordinate Determine whether the specified radius can cover the front and rear houses: Go through each heater Two-point query heater heating radius can cover the leftmost house number If the leftmost radius cannot overlap with the last rightmost, it means that the heating cannot be covered Update the rightmost house number that the current heater radius can cover If the last house can be reached, the coverage is complete 12345678910111213141516171819202122232425# O((n+m)logn) time | O(logn) spaceclass Solution: def findRadius(self, houses: List[int], heaters: List[int]) -&gt; int: houses.sort() heaters.sort() l, r = 0, max(houses[-1], heaters[-1]) while l &lt;= r: mid = l + (r-l)//2 if self.canHeat(mid, heaters, houses): r = mid-1 else: l = mid+1 return l def canHeat(self, radius, heaters, houses): pre_house = 0 for heater in heaters: cover = bisect.bisect_left(houses, heater-radius) if cover &gt; pre_house: return False pre_house = bisect.bisect_right(houses, heater+radius) if pre_house &gt;= len(houses): return True return False 1.475. Heaters ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"}]},{"title":"LC2055 - Plates Between Candles","slug":"LC2055PlatesBetweenCandles","date":"2022-06-07T12:31:35.000Z","updated":"2022-06-07T12:31:35.000Z","comments":true,"path":"2022/06/07/LC2055PlatesBetweenCandles/","permalink":"http://hexuanweng.github.io/2022/06/07/LC2055PlatesBetweenCandles/","excerpt":"","text":"DescriptionThere is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters ‘*‘ and ‘|’ only, where a ‘*‘ represents a plate and a ‘|’ represents a candle. You are also given a 0-indexed 2D integer array queries where queries[i] &#x3D; [lefti, righti] denotes the substring s[lefti…righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring. For example, s &#x3D; “||**||**|*“, and a query [3, 8] denotes the substring “*||**|”. The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.Return an integer array answer where answer[i] is the answer to the ith query. Example 1: Input: s &#x3D; “**|**|***|”, queries &#x3D; [[2,5],[5,9]]Output: [2,3]Explanation: queries[0] has two plates between candles. queries[1] has three plates between candles.Example 2: ex-2Input: s &#x3D; “***|**|*****|**||**|*”, queries &#x3D; [[1,17],[4,5],[14,17],[5,11],[15,16]]Output: [9,0,0,0,0]Explanation: queries[0] has nine plates between candles. The other queries have zero plates between candles. Constraints: 3 &lt;&#x3D; s.length &lt;&#x3D; 105s consists of ‘*‘ and ‘|’ characters.1 &lt;&#x3D; queries.length &lt;&#x3D; 105queries[i].length &#x3D;&#x3D; 20 &lt;&#x3D; lefti &lt;&#x3D; righti &lt; s.length Solution the position of the first candle to the right of the left endpoint the position of the first candle to the left of the right endpoint how many plates are between these two candles Counting the nearest candle to the left and the nearest candle to the right of each point is a kind of simple dynamic programming. And finding the quantity of a certain type between two points is the standard prefix and application. 12345678910111213141516171819202122232425262728# O(n) time | O(n) spaceclass Solution: def platesBetweenCandles(self, s: str, queries: List[List[int]]) -&gt; List[int]: length = len(s) presum = [0] lefts, rights = [-1] * length, [-1] * length l,r = -1, -1 for i, v in enumerate(s): if v == &quot;*&quot;: presum.append(presum[-1]+1) else: presum.append(presum[-1]) l = i lefts[i] = l for i, v in enumerate(s[::-1]): if v == &quot;|&quot;: r = length - 1 - i rights[length-1-i] = r res = [0] * len(queries) for i, query in enumerate(queries): left = rights[query[0]] right = lefts[query[1]] if left &gt;= 0 and right &gt;= 0 and left &lt; right: res[i] = presum[right] - presum[left] return res 1.2055. Plates Between Candles ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"}]},{"title":"LC875 - Koko Eating Bananas","slug":"LC875KokoEatingBananas","date":"2022-06-07T12:14:05.000Z","updated":"2022-06-07T12:14:05.000Z","comments":true,"path":"2022/06/07/LC875KokoEatingBananas/","permalink":"http://hexuanweng.github.io/2022/06/07/LC875KokoEatingBananas/","excerpt":"","text":"DescriptionKoko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours. Example 1: Input: piles &#x3D; [3,6,7,11], h &#x3D; 8Output: 4Example 2: Input: piles &#x3D; [30,11,23,4,20], h &#x3D; 5Output: 30Example 3: Input: piles &#x3D; [30,11,23,4,20], h &#x3D; 6Output: 23 Constraints: 1 &lt;&#x3D; piles.length &lt;&#x3D; 104piles.length &lt;&#x3D; h &lt;&#x3D; 1091 &lt;&#x3D; piles[i] &lt;&#x3D; 109 Solution According to the meaning of the question, you can know that the slower Koko eats bananas, the more time it takes. On the contrary, the greater the speed, the less time-consuming, which is the monotonicity of the problem; What we’re looking for is speed. Because the question limits Koko to eat only a bunch of bananas within an hour, so the maximum speed is the one with the largest number of these bunches of bananas. The minimum value of the speed is 11, in fact, you can also analyze what the lower bound is. Since the time complexity of binary search is very low, rigorous analysis is not necessary; Or because Koko can only choose a bunch of bananas to eat within an hour, so: the time it takes to eat each bunch of bananas &#x3D; the number of bananas in this bunch &#x2F; the number of bananas that Koko eats in an hour. According to the meaning of the question, when &#x2F; is not divisible, it needs to be rounded up. Note: When the guessing speed of the “binary search” algorithm is just enough to make Koko eat the bananas within the specified time, you should try a smaller speed to ensure that you can eat the bananas within the specified time.This is because the question asks about “minimum speed”. 1234567891011121314151617181920212223242526# O(nlogm) time | O(1) spaceclass Solution: def minEatingSpeed(self, piles: List[int], h: int) -&gt; int: l = 1 r = max(piles) while l &lt; r: mid = l + (r-l)//2 if self.canFinish(piles, mid, h): r = mid else: l = mid if l == r-1: if self.canFinish(piles, l, h): r = l break return r def canFinish(self, piles, speed, hour): total = 0 for pile in piles: total+= math.ceil(pile/speed) if total &gt; hour: return False return True 12345678910111213141516171819202122232425262728# Official Solution: Binary Search (More readable version)# O(nlogm) time | O(1) spaceclass Solution: def minEatingSpeed(self, piles: List[int], h: int) -&gt; int: # Initalize the left and right boundaries left = 1 right = max(piles) while left &lt; right: # Get the middle index between left and right boundary indexes. # hour_spent stands for the total hour Koko spends. middle = (left + right) // 2 hour_spent = 0 # Iterate over the piles and calculate hour_spent. # We increase the hour_spent by ceil(pile / middle) for pile in piles: hour_spent += math.ceil(pile / middle) # Check if middle is a workable speed, and cut the search space by half. if hour_spent &lt;= h: right = middle else: left = middle + 1 # Once the left and right boundaries coincide, we find the target value, # that is, the minimum workable eating speed. return right 1.875. Koko Eating Bananas ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://hexuanweng.github.io/tags/Binary-Search/"}]},{"title":"LC1894 - Find the Student That Will Replace the Chalk","slug":"LC1894FindtheStudentthatWillReplacetheChalk","date":"2022-06-06T13:09:24.000Z","updated":"2022-06-06T13:09:24.000Z","comments":true,"path":"2022/06/06/LC1894FindtheStudentthatWillReplacetheChalk/","permalink":"http://hexuanweng.github.io/2022/06/06/LC1894FindtheStudentthatWillReplacetheChalk/","excerpt":"","text":"DescriptionThere are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again. You are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk. Return the index of the student that will replace the chalk. Example 1: Input: chalk &#x3D; [5,1,5], k &#x3D; 22Output: 0Explanation: The students go in turns as follows: Student number 0 uses 5 chalk, so k &#x3D; 17. Student number 1 uses 1 chalk, so k &#x3D; 16. Student number 2 uses 5 chalk, so k &#x3D; 11. Student number 0 uses 5 chalk, so k &#x3D; 6. Student number 1 uses 1 chalk, so k &#x3D; 5. Student number 2 uses 5 chalk, so k &#x3D; 0.Student number 0 does not have enough chalk, so they will have to replace it.Example 2: Input: chalk &#x3D; [3,4,1,2], k &#x3D; 25Output: 1Explanation: The students go in turns as follows: Student number 0 uses 3 chalk so k &#x3D; 22. Student number 1 uses 4 chalk so k &#x3D; 18. Student number 2 uses 1 chalk so k &#x3D; 17. Student number 3 uses 2 chalk so k &#x3D; 15. Student number 0 uses 3 chalk so k &#x3D; 12. Student number 1 uses 4 chalk so k &#x3D; 8. Student number 2 uses 1 chalk so k &#x3D; 7. Student number 3 uses 2 chalk so k &#x3D; 5. Student number 0 uses 3 chalk so k &#x3D; 2.Student number 1 does not have enough chalk, so they will have to replace it. Constraints: chalk.length &#x3D;&#x3D; n1 &lt;&#x3D; n &lt;&#x3D; 1051 &lt;&#x3D; chalk[i] &lt;&#x3D; 1051 &lt;&#x3D; k &lt;&#x3D; 109 Solution Use k to modulo the sum of chalk Use the modulo result to compare the elements of chalk. If less than zero, the current student needs to replace the chalk 1234567891011# O(n) time | O(1) spaceclass Solution: def chalkReplacer(self, chalk: List[int], k: int) -&gt; int: summ = sum(chalk) k %= summ for i in range(len(chalk)): if k - chalk[i] &lt; 0: return i else: k -= chalk[i] 1.1894. Find the Student that Will Replace the Chalk ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Simulation","slug":"Simulation","permalink":"http://hexuanweng.github.io/tags/Simulation/"}]},{"title":"LC238 - Product of Array Except Self","slug":"LC238ProductofArrayExceptSelf","date":"2022-06-06T12:56:40.000Z","updated":"2022-06-06T12:56:40.000Z","comments":true,"path":"2022/06/06/LC238ProductofArrayExceptSelf/","permalink":"http://hexuanweng.github.io/2022/06/06/LC238ProductofArrayExceptSelf/","excerpt":"","text":"DescriptionGiven an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums &#x3D; [1,2,3,4]Output: [24,12,8,6]Example 2: Input: nums &#x3D; [-1,1,0,-3,3]Output: [0,0,9,0,0] Constraints: 2 &lt;&#x3D; nums.length &lt;&#x3D; 105-30 &lt;&#x3D; nums[i] &lt;&#x3D; 30The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Solution Traverse nums once from left to right, and store the product of the current number in the remaining product result Traverse nums once from right to left, and store the product of the right side of the current number in the result of the correct product Multiply the results of the left product and the right product, which is the product of the numbers other than yourself optimization: In the last traversal from left to right, store the result directly in the loop of numbers from right to right. 123456789101112131415161718192021222324252627282930# O(n) time | O(n) spaceclass Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: leftproduct = [1 for _ in range(len(nums))] rightproduct = [1 for _ in range(len(nums))] for i in range(1, len(nums)): leftproduct[i] = leftproduct[i-1] * nums[i-1] for i in reversed(range(len(nums)-1)): rightproduct[i] = rightproduct[i+1] * nums[i+1] for i in range(len(nums)): leftproduct[i] *= rightproduct[i] return leftproduct# O(n) time | O(1) spaceclass Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: res = [1 for _ in range(len(nums))] for i in range(1, len(nums)): res[i] = res[i-1] * nums[i-1] temp = 1 for i in reversed(range(len(nums))): res[i] = temp * res[i] temp *= nums[i] return res 1.238. Product of Array Except Self ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"}]},{"title":"LC478 - Generate Random Point in a Circle","slug":"LC478GenerateRandomPointinaCircle","date":"2022-06-05T06:03:14.000Z","updated":"2022-06-05T06:03:14.000Z","comments":true,"path":"2022/06/05/LC478GenerateRandomPointinaCircle/","permalink":"http://hexuanweng.github.io/2022/06/05/LC478GenerateRandomPointinaCircle/","excerpt":"","text":"DescriptionGiven the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle. Implement the Solution class: Solution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).randPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y]. Example 1: Input[“Solution”, “randPoint”, “randPoint”, “randPoint”][[1.0, 0.0, 0.0], [], [], []]Output[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]] ExplanationSolution solution &#x3D; new Solution(1.0, 0.0, 0.0);solution.randPoint(); &#x2F;&#x2F; return [-0.02493, -0.38077]solution.randPoint(); &#x2F;&#x2F; return [0.82314, 0.38945]solution.randPoint(); &#x2F;&#x2F; return [0.36572, 0.17248] Constraints: 0 &lt; radius &lt;&#x3D; 108-107 &lt;&#x3D; x_center, y_center &lt;&#x3D; 107At most 3 * 104 calls will be made to randPoint. SolutionThe x-axis and y-axis correspond to uniform pixels, but such numbers will be inside the circle, as shown in the figure below, and may appear in blue. The easiest way to deal with it is to use Pythagorean theorem check whether the random point is in the circle, and if it is not, resample it again until the result is randomly generated. 12345678910111213141516171819# O(1) time | O(1) spaceclass Solution: def __init__(self, radius: float, x_center: float, y_center: float): self.r = radius self.x = x_center self.y = y_center def randPoint(self) -&gt; List[float]: while True: x, y = random.uniform(-self.r, self.r), random.uniform(-self.r, self.r) if x*x + y*y &lt;= self.r * self.r: return [self.x+x, self.y+y] # Your Solution object will be instantiated and called as such:# obj = Solution(radius, x_center, y_center)# param_1 = obj.randPoint() Random Usage uniform(): Returns a random float number between two given parameters randint(): Returns a random number between the given range choice(): Returns a random element from the given sequence random(): Returns a random float number between 0 and 1 1.478. Generate Random Point in a Circle ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Rejection Sampling","slug":"Rejection-Sampling","permalink":"http://hexuanweng.github.io/tags/Rejection-Sampling/"}]},{"title":"LC396 - Rorate Function","slug":"LC396RorateFunction","date":"2022-06-05T05:06:57.000Z","updated":"2022-06-05T05:06:57.000Z","comments":true,"path":"2022/06/05/LC396RorateFunction/","permalink":"http://hexuanweng.github.io/2022/06/05/LC396RorateFunction/","excerpt":"","text":"DescriptionYou are given an integer array nums of length n. Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow: F(k) &#x3D; 0 * arrk[0] + 1 * arrk[1] + … + (n - 1) * arrk[n - 1].Return the maximum value of F(0), F(1), …, F(n-1). The test cases are generated so that the answer fits in a 32-bit integer. Example 1: Input: nums &#x3D; [4,3,2,6]Output: 26Explanation:F(0) &#x3D; (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) &#x3D; 0 + 3 + 4 + 18 &#x3D; 25F(1) &#x3D; (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) &#x3D; 0 + 4 + 6 + 6 &#x3D; 16F(2) &#x3D; (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) &#x3D; 0 + 6 + 8 + 9 &#x3D; 23F(3) &#x3D; (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) &#x3D; 0 + 2 + 12 + 12 &#x3D; 26So the maximum value of F(0), F(1), F(2), F(3) is F(3) &#x3D; 26.Example 2: Input: nums &#x3D; [100]Output: 0 Constraints: n &#x3D;&#x3D; nums.length1 &lt;&#x3D; n &lt;&#x3D; 105-100 &lt;&#x3D; nums[i] &lt;&#x3D; 100 Solution12345678910111213141516171819nums: [A0,A1,A2,A3] F0 = 0*A0 + 1*A1 + 2*A2 + 3*A3 F1 = 0*A3 + 1*A0 + 2*A1 + 3*A2 = F0 + A0 + A1 + A2 - 3*A3 = F0 + sum-A3 - 3*A3 = F0 + sum - 4*A3 F2 = 0*A2 + 1*A3 + 2*A0 + 3*A1 = F1 + A3 + A0 + A1 - 3*A2 = F1 + sum - 4*A2 F3 = 0*A1 + 1*A2 + 2*A3 + 3*A0 = F2 + A2 + A3 + A0 - 3*A1 = F2 + sum - 4*A1Formula：F(i) = F(i-1) + sum - n * A(n-i) 1234567891011121314# O(n) time | O(1) spaceclass Solution: def maxRotateFunction(self, nums: List[int]) -&gt; int: summ = sum(nums) length = len(nums) f_pre=0 for i, v in enumerate(nums): f_pre += i*v res = f_pre for i in range(length): f_pre = f_pre + summ - length * nums[length-1-i] res = max(res, f_pre) return res 1.396. Rotate Function ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"array","slug":"array","permalink":"http://hexuanweng.github.io/tags/array/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"}]},{"title":"LC929 - Unique Email Address","slug":"LC929UniqueEmailAddress","date":"2022-06-04T09:44:29.000Z","updated":"2022-06-04T09:44:29.000Z","comments":true,"path":"2022/06/04/LC929UniqueEmailAddress/","permalink":"http://hexuanweng.github.io/2022/06/04/LC929UniqueEmailAddress/","excerpt":"","text":"DescriptionEvery valid email consists of a local name and a domain name, separated by the ‘@’ sign. Besides lowercase letters, the email may contain one or more ‘.’ or ‘+’. For example, in “&#97;&#108;&#105;&#x63;&#x65;&#64;&#108;&#x65;&#x65;&#x74;&#99;&#111;&#x64;&#x65;&#x2e;&#99;&#111;&#x6d;“, “alice” is the local name, and “leetcode.com” is the domain name.If you add periods ‘.’ between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names. For example, “&#97;&#x6c;&#105;&#x63;&#101;&#x2e;&#x7a;&#64;&#x6c;&#x65;&#101;&#x74;&#x63;&#x6f;&#x64;&#x65;&#x2e;&#x63;&#x6f;&#x6d;“ and “&#97;&#108;&#x69;&#99;&#101;&#x7a;&#x40;&#108;&#x65;&#101;&#x74;&#x63;&#111;&#x64;&#101;&#46;&#x63;&#x6f;&#109;“ forward to the same email address.If you add a plus ‘+’ in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names. For example, “&#x6d;&#46;&#121;&#x2b;&#x6e;&#x61;&#109;&#x65;&#64;&#x65;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;“ will be forwarded to “&#x6d;&#121;&#x40;&#x65;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;“.It is possible to use both of these rules at the same time. Given an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails. Example 1: Input: emails &#x3D; [“&#116;&#101;&#x73;&#x74;&#46;&#x65;&#x6d;&#97;&#105;&#108;&#x2b;&#97;&#108;&#101;&#x78;&#64;&#108;&#x65;&#101;&#x74;&#99;&#x6f;&#x64;&#x65;&#x2e;&#x63;&#111;&#x6d;“,”&#x74;&#101;&#115;&#x74;&#46;&#x65;&#x2e;&#109;&#x61;&#x69;&#x6c;&#43;&#98;&#x6f;&#x62;&#x2e;&#x63;&#97;&#116;&#104;&#x79;&#64;&#x6c;&#x65;&#101;&#116;&#99;&#111;&#x64;&#x65;&#46;&#x63;&#111;&#x6d;“,”&#116;&#x65;&#x73;&#116;&#101;&#109;&#97;&#105;&#108;&#43;&#x64;&#x61;&#x76;&#x69;&#x64;&#x40;&#108;&#101;&#101;&#x2e;&#116;&#x63;&#x6f;&#100;&#101;&#x2e;&#99;&#111;&#109;“]Output: 2Explanation: “&#116;&#x65;&#115;&#x74;&#x65;&#x6d;&#97;&#x69;&#108;&#x40;&#x6c;&#101;&#x65;&#x74;&#99;&#x6f;&#x64;&#101;&#46;&#x63;&#x6f;&#x6d;“ and “&#x74;&#101;&#115;&#116;&#x65;&#x6d;&#97;&#105;&#x6c;&#x40;&#x6c;&#x65;&#101;&#x2e;&#x74;&#x63;&#x6f;&#x64;&#x65;&#x2e;&#x63;&#111;&#109;“ actually receive mails.Example 2: Input: emails &#x3D; [“&#x61;&#x40;&#x6c;&#101;&#x65;&#116;&#x63;&#x6f;&#100;&#101;&#46;&#x63;&#111;&#109;“,”&#98;&#64;&#x6c;&#101;&#x65;&#116;&#x63;&#x6f;&#x64;&#x65;&#46;&#99;&#x6f;&#x6d;“,”&#x63;&#x40;&#108;&#x65;&#x65;&#x74;&#x63;&#x6f;&#100;&#x65;&#x2e;&#x63;&#111;&#109;“]Output: 3 Constraints: 1 &lt;&#x3D; emails.length &lt;&#x3D; 1001 &lt;&#x3D; emails[i].length &lt;&#x3D; 100emails[i] consist of lowercase English letters, ‘+’, ‘.’ and ‘@’.Each emails[i] contains exactly one ‘@’ character.All local and domain names are non-empty.Local names do not start with a ‘+’ character.Domain names end with the “.com” suffix. Solution Based on the description, the rules apply differently for name and domain. Therefore, we split them and use different approaches We can either use List or Set to store the data 12345678910111213141516171819202122232425262728# O(L) time | O(L) space# Use Listclass Solution: def numUniqueEmails(self, emails: List[str]) -&gt; int: res = [] for email in emails: local, domain = email.split(&#x27;@&#x27;) local = local.replace(&#x27;.&#x27;, &#x27;&#x27;) local = local.split(&#x27;+&#x27;)[0] merge = local+&quot;@&quot;+domain if merge not in res: res.append(merge) return len(res)#Use Setclass Solution: def numUniqueEmails(self, emails: List[str]) -&gt; int: res = set() for email in emails: local, domain = email.split(&#x27;@&#x27;) local = local.replace(&#x27;.&#x27;, &#x27;&#x27;) local = local.split(&#x27;+&#x27;)[0] merge = local+&quot;@&quot;+domain res.add(merge) return len(res) 1.929. Unique Email Addresses ↩2.Hex Solution ↩","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Brute Force","slug":"Brute-Force","permalink":"http://hexuanweng.github.io/tags/Brute-Force/"}]},{"title":"Access-Google-BigQuery-Metadata-From-AWS-Lambda","slug":"Access-Google-BigQuery-Metadata-From-AWS-Lambda","date":"2021-10-06T10:18:11.000Z","updated":"2021-10-06T10:18:11.000Z","comments":true,"path":"2021/10/06/Access-Google-BigQuery-Metadata-From-AWS-Lambda/","permalink":"http://hexuanweng.github.io/2021/10/06/Access-Google-BigQuery-Metadata-From-AWS-Lambda/","excerpt":"","text":"Requirements: Try to get the Metadata from Google BigQuery by using AWS Lambda function Build connection between AWS Lambda and Google BigQuery Write Python code to get metadata from Google BigQuery format the metadata schema Solution Get google-cloud-bigquery.zip Method 1 Instead of getting the GCP Layer via EC2 and Session, You can also download the zip file locally by running the following code 12pip install google-cloud-bigquery -t ./python/zip -r google-cloud-bigquery.zip python Add the zip file to Lambda function as a layer from your local device Get google-cloud-bigquery.zip Method 2Create EC2 in AWS create an EC2 Amazon Linux 2 free tier is enough- instance type: t2.micro the IAM role grants only “Amazon EC2Role for SSM“ so that Session Manager of Systems Manager can connect to this EC2 leave the other options as default Get AWS Access Key ID and Secret Access Key Go to service “Identity and Access Management” click “Users” and find your user name click “Security credentials” create access key and please remember that you can only view the credential once. Start a Session in AWS go to service “AWS System Manager” click the tab “Session Manager” click “Start a Session” 1234567891011121314151617181920212223242526# ec2-Become a usersudo su - ec2-user#pip installationsudo yum install python3 -ycurl -O https://bootstrap.pypa.io/get-pip.pysudo python3 get-pip.pyexport PATH=$PATH:/usr/local/bin#sdk installation&amp;Zippip install google-cloud-bigquery -t ./python/zip -r google-cloud-bigquery.zip python#Added because protobuf is requiredpip install protobuf --upgrade -t ./python/zip -r google-cloud-bigquery.zip ./python/google/protobuf#aws cli settingsaws configure#Set the following: AWS Access Key ID [None]: &lt;my-access-key&gt; AWS Secret Access Key [None]: &lt;my-secret-key&gt; Default region name [None]: ap-southeast-2 Default output format [None]: json#Save to s3aws s3 mb s3://&lt;my-bucket&gt;aws s3 cp google-cloud-bigquery.zip s3://&lt;my-bucket&gt; Check S3 Bucket in AWS go to the s3 bucket you created just now by using Session Manager You should see google-cloud-bigquery.zip should be uploaded Other Stepscreate a lambda function and register the created library in the lambda layer in AWS go to Lambda service Click “Function” and “create function” changes settings: Timeout: 30 seconds create Layer add Layer: gcp-bigquery And you should see the data has been created successfully Get GCP certificate file in Google Cloud Platform Log into Google Cloud Platform go to “IAM&amp;Admin” service and go to “Service Accounts” Click “Create Service Account”: please make sure that you choose “BigQuery Admin” as the Role Once you created the account, please click the account and “ADD KEY” You are able to download the JSON file in the following format 123456789101112&#123; &quot;type&quot;: &quot;xxx&quot;, &quot;project_id&quot;: &quot;xxx&quot;, &quot;private_key_id&quot;: &quot;xxx&quot;, &quot;private_key&quot;: &quot;xxx&quot;, &quot;client_email&quot;: &quot;xxx&quot;, &quot;client_id&quot;: &quot;xxx&quot;, &quot;auth_uri&quot;: &quot;xxx&quot;, &quot;token_uri&quot;: &quot;xxx&quot;, &quot;auth_provider_x509_cert_url&quot;: &quot;xxx&quot;, &quot;client_x509_cert_url&quot;: &quot;xxx&quot;,&#125; Add functions and credential file in AWS Lambda Function copy the JSON file into “bq.manager.json” copy the following codes into “lambda_function.py” 12345678910111213141516171819import jsonfrom google.cloud import bigquerydef lambda_handler(event, context): client = bigquery.Client() sql = &quot;&quot;&quot; SELECT * FROM `&lt;project name&gt;.&lt;dataset name&gt;.&lt;table name&gt;` &quot;&quot;&quot; # Run a Standard SQL query using the environment&#x27;s default project results = client.query(sql).result() metadata_objects = [] for row in results: id_dic = &#123;&quot;id&quot;: list(row)[0]&#125; other_dic = &#123;&quot;metadata&quot;: list(row)[1]&#125; metadata_objects.append(&#123;**id_dic, **other_dic&#125;) return metadata_objects Add “GOOGLE_APPLICATION_CREDENTIALS: bq-manager.json” as Environment Variables Test ResultYou should be able to get the JSON result like the format in the BigQuery. By default, you should get a SQL table. You can modify the result baesd on your code. Updated SolutionsAWS SSM - Parameter Store Store the credential paths in the SSM Parameter Store like a Python Dictionary AWS Lambda - Environment Variable Set all the paths as an environment variables Updated Lambda code1234567891011121314151617181920212223242526272829303132333435363738394041424344from google.cloud import bigqueryfrom google.oauth2 import service_accountimport boto3import jsonimport osssm = boto3.client(&#x27;ssm&#x27;)def lambda_handler(event, context): #retrieve parameters from ssm/appconfig and prepare for connection with BigQuery client_email_var = ssm.get_parameter(Name=os.getenv(&#x27;SSM_BQ_CLIENT_EMAIL&#x27;))[&#x27;Parameter&#x27;][&#x27;Value&#x27;] private_key_var = ssm.get_parameter(Name=os.getenv(&#x27;SSM_BQ_PRIVATE_KEY&#x27;))[&#x27;Parameter&#x27;][&#x27;Value&#x27;].replace(&#x27;\\\\n&#x27;, &#x27;\\n&#x27;) token_uri_var = os.getenv(&#x27;SSM_BQ_TOKEN_URI&#x27;) credentials = service_account.Credentials.from_service_account_info( &#123; &quot;client_email&quot;: client_email_var, &quot;private_key&quot;: private_key_var, &quot;token_uri&quot;: token_uri_var &#125; ) project_id_var = os.getenv(&#x27;BQ_PROJECT_ID&#x27;) dataset_name_var = os.getenv(&#x27;BQ_DATASET_NAME&#x27;) table_name_var = os.getenv(&#x27;BQ_TABLE_NAME&#x27;) if bigquery.Client(credentials = credentials,project=project_id_var): client = bigquery.Client(credentials = credentials,project=project_id_var) else: raise GCPConnectionError sql = f&quot;&quot;&quot; SELECT * FROM &#123;project_id_var&#125;.&#123;dataset_name_var&#125;.&#123;table_name_var&#125; &quot;&quot;&quot; # Run a Standard SQL query using the environment&#x27;s default project #retrieve metadata from Bigquery and transfer it to JSON results = client.query(sql).result() metadata_objects = [] for row in results: id_dic = &#123;&quot;id&quot;: list(row)[0]&#125; other_dic = &#123;&quot;metadata&quot;: list(row)[1]&#125; metadata_objects.append(&#123;**id_dic, **other_dic&#125;) return metadata_objects 1.google-cloud-bigquery ↩2.Authentication overview | Google Cloud ↩2.Run BigQuery from Lambda ↩","categories":[{"name":"AWS","slug":"AWS","permalink":"http://hexuanweng.github.io/categories/AWS/"}],"tags":[{"name":"AWS Lambda","slug":"AWS-Lambda","permalink":"http://hexuanweng.github.io/tags/AWS-Lambda/"},{"name":"Google BigQuery","slug":"Google-BigQuery","permalink":"http://hexuanweng.github.io/tags/Google-BigQuery/"}]},{"title":"Leetcode-Candy","slug":"Leetcode-Candy","date":"2021-01-28T13:03:24.000Z","updated":"2021-01-28T13:03:24.000Z","comments":true,"path":"2021/01/29/Leetcode-Candy/","permalink":"http://hexuanweng.github.io/2021/01/29/Leetcode-Candy/","excerpt":"","text":"Questions There are N children standing in a line. Each child is assigned a rating value.You are giving candies to these children subjected to the following requirements:Each child must have at least one candy.Children with a higher rating get more candies than their neighbors.What is the minimum candies you must give? 12345678Input: [1,0,2]Output: 5#Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.Input: [1,2,2]Output: 4Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions. Key Point This question can have the same number in succession. The peaks and valleys method is not very practical for this question. Because there are many situations to consider, there will be many special situations. The more recommended is the left-right, right-left method~ It is equivalent to using the Approach3 method in Min Rewards. My Solution123456789101112# O(n) time | O(n) Spaceclass Solution: def candy(self, ratings: List[int]) -&gt; int: candies = [1 for _ in ratings] for i in range(1, len(ratings)): if ratings[i-1] &lt; ratings[i]: candies[i] = candies[i-1]+1 for j in reversed(range(len(ratings)-1)): if ratings[j] &gt; ratings[j+1]: candies[j] = max(candies[j], candies[j+1]+1) return sum(candies) 1.Candy-Leetcode challenge question ↩2.Similiar Question: Min Rewards ↩","categories":[{"name":"Data Structure and Algorithm","slug":"Data-Structure-and-Algorithm","permalink":"http://hexuanweng.github.io/categories/Data-Structure-and-Algorithm/"}],"tags":[{"name":"array","slug":"array","permalink":"http://hexuanweng.github.io/tags/array/"},{"name":"hard","slug":"hard","permalink":"http://hexuanweng.github.io/tags/hard/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/tags/Leetcode/"}]},{"title":"Algo-MinRewards","slug":"Algo-MinRewards","date":"2021-01-28T11:48:25.000Z","updated":"2021-01-28T11:48:25.000Z","comments":true,"path":"2021/01/28/Algo-MinRewards/","permalink":"http://hexuanweng.github.io/2021/01/28/Algo-MinRewards/","excerpt":"","text":"Questions Imagine that you are a teacher who is just graded the final exam in a class. You have a list of student scores on the final exam in a particular order (not necessarily sorted), and you want to reward your students. You decide to do so fairly by giving them arbitrary rewards following two rules: All students must receive at least one reward Any given student must receive strictly more rewards than an adjacent student (a student immediately to the left or to the right) with a lower score and must receive strictly fewer rewards than an adjacent student with a higher score.Write a function that takes in a list of scores and returns the minimum number of rewards that you must give out to students to satisfy the two rules.You can assume that all students have different scores; in other words, the scores are all unique. 1234#inputscores = [8,4,2,1,3,6,7,9,5]#output25 # you would give out the following rewards: [4, 3, 2, 1, 2, 3, 4, 5, 1] IdeasI am very happy to pass this question once in 15 minutes. The main personal ideas are as follows: For the first traverse, first find out the local minimum and local maximum. The local minimum is directly set to 1, and the local maximum is set to’x’ because I don’t know what it is. For the second traverse, expand left to right in the direction of 1, during the process of expanding to the left, if it exceeds the boundary and encounters’x’ and stops, during the process of expanding to the right, if it exceeds the boundary and encounters’x’ stop For the third traverse, it stops where it encounters ‘x’, compare the numbers on the left and right, the larger number + 1 is the value of x Return sum (rewards) Several key points orders matter the scores are unique all numbers are positive Several methods given in AlgoExpert:1. naive algorithm Starting from the first number, the first number is set to 1, from left to right, if it is smaller than the previous number, it is currently changed to 1, and 1 is added to the front Disadvantages: need back tracking&#x2F;iterate back to the previous one. Time: O(n^2), Space: O(n) 2. techniques: peaks and valleys&#x2F;high points and low points&#x2F; local maxes and local mins I use this method if I am at a local min, start expanding to the left and expanding to the right, until I reach the peaks and incrementing stop once I get a peak or boundary But unlike my method, I found peaks and valleys, but the video only needs valleys, not peaks Time: O(n), Space: O(n) Disadvantages: The code is relatively long, so many edge cases need to be considered 3. The best way, cleverest solution the idea of ​​expanding to left and to right of local mins doesn’t actually have to happen by starting at the local mins Just go from left to right, then from right to left, traverse twice, and set all numbers at the beginning to be 1. From left to right: start from the second number, compare with the left, if the current number is smaller than the left, skip it, if it is larger, start adding 1 From right to left: If the current number is smaller than the right, the right starts to add Advantages: There is no need to consider many edge cases, and the code is clearer, but no faster than method two Time: O(n), Space: O(n) My SolutionPeaks and ValleysFirst solution peaks and valleys (original solution without refering to any materials)12345678910111213141516171819202122232425262728293031def minRewards(scores): # Write your code here. rewards = [0] * len(scores) cur = 0 if len(scores) == 1: return 1 if scores[0] &lt; scores[1]: rewards[0] = 1 if scores[-1] &lt; scores[-2]: rewards[-1] = 1 for i in range(1, len(scores)-1): if scores[i] &lt; scores[i-1] and scores[i] &lt; scores[i+1]: rewards[i] = 1 elif scores[i] &gt; scores[i-1] and scores[i] &gt; scores[i+1]: rewards[i] = &quot;x&quot; for j in range(len(rewards)): if rewards[j] == 1: left = j-1 while left &gt;= 0 and rewards[left] != &#x27;x&#x27;: rewards[left] += rewards[left+1]+1 left-=1 right = j+1 while right &lt; len(rewards) and rewards[right] !=&#x27;x&#x27;: rewards[right] = rewards[right-1]+1 right+=1 for k in range(len(rewards)): if rewards[k] == &#x27;x&#x27;: rewards[k] = max(rewards[k-1], rewards[k+1])+1 return sum(rewards) Best SolutionClean and better solution Need to pay attation to researsed traverse.1234567891011#看了视频以后写的代码，比较绕的是reversed traversedef minRewards(scores): # Write your code here. rewards = [1] * len(scores) for i in range(1, len(scores)): if scores[i-1] &lt; scores[i]: rewards[i] +=rewards[i-1] for j in reversed(range(1, len(scores))): if scores[j-1] &gt; scores[j]: rewards[j-1] = max(rewards[j-1], 1+rewards[j]) return sum(rewards) Tipsmy way: rewards &#x3D; [1]*len(scores)better way: rewards &#x3D; [1 for _ in scores]","categories":[{"name":"Data Structure and Algorithm","slug":"Data-Structure-and-Algorithm","permalink":"http://hexuanweng.github.io/categories/Data-Structure-and-Algorithm/"}],"tags":[{"name":"array","slug":"array","permalink":"http://hexuanweng.github.io/tags/array/"},{"name":"hard","slug":"hard","permalink":"http://hexuanweng.github.io/tags/hard/"},{"name":"AlgoExpert","slug":"AlgoExpert","permalink":"http://hexuanweng.github.io/tags/AlgoExpert/"}]},{"title":"Hello, Notion!!","slug":"Notion-2021-v1","date":"2020-12-24T11:18:11.000Z","updated":"2020-12-24T11:18:11.000Z","comments":true,"path":"2020/12/24/Notion-2021-v1/","permalink":"http://hexuanweng.github.io/2020/12/24/Notion-2021-v1/","excerpt":"","text":"TechoI am a big fan of kinds of notebooks and I am addicted to taking notes. In November 2019, I spend $50 on Kokuyo Jibun Techo. I got hooked on this type of way to record my daily life. I stick to it during the covid and somehow I gave up after this September. Kokuyo Jibun TechoA complete set of Kokuyo Jibun Techo includes three sub-books: Diary, Life and Idea. Diary is a daily account with a timeline as the main body. There are various lists in Life, such as life dreams, travel plans, etc., and Idea is a grid book for recording daily essays and inspirations. NotionNotion is my currently favourite note-taking application. From my perspective, it beats Microsoft OneNote and any other note-taking applications. I can do customized design based on my own preference. Due to my previous experience on Kokuyo Jibun Techo, I do have some novel ideas to make an electronical techo for myself and for the coming 2021. My First NotionI don’t think I’m naturally intelligent, but I find that I don’t seem to know what renunciation is ~ I hope I never give up on the unknown future. Homepage HomePage 2021 Techo my plan for 2021 Life important events yearly goals Lists reading list travel plans journeys Study Work Fig. 1: Hana Notion Homepage Fig. 2: Hana Notion My Life Page 2021 Techo 2021 Techo Inbox inspirations mood favourite paragraphs picked up on a daily basis Roommate Home Motto 2021 Time Management monthly plan from Jan to Dec 2021 Budget monthly budget from Jan to Dec 2021 Yearly yearly calendar my 2021 targets the way to hit the targets Fig. 3: Hana Notion 2021 Techo Fig. 4: Hana Notion Roommate Home Page1 Fig. 5: Hana Notion Roommate Home Page1 Fig. 6: Hana Notion Monthly Plan Page1 Fig. 7: Hana Notion Monthly Plan Page2 Fig. 8: Hana Notion Budget Plan Page SummaryMy younger brother recommended this application to me yesterday and I started using this app after I woke up this morning. It is a little bit hard for me to find my own way to design my own notion. All the color match, layouts and design took me a long time. I suppose to do some study today but I was addicted to notion. I feel satisfied that I have something done at least. I like my current design and I may change all the design one day. Looking forward to my second version of Hana’s Notion~ By the way, today is Christmas Eve. Julian’s family shouted me a yummy dinner tonight. I appreciate it. Merry Christmas 🎄 1.Notion ↩2.Peru Icon Pack ↩","categories":[{"name":"Other","slug":"Other","permalink":"http://hexuanweng.github.io/categories/Other/"}],"tags":[{"name":"Notion","slug":"Notion","permalink":"http://hexuanweng.github.io/tags/Notion/"}]},{"title":"Support Vector Machines Main Idea","slug":"SVM-Concept","date":"2020-12-23T03:36:14.000Z","updated":"2020-12-23T03:36:14.000Z","comments":true,"path":"2020/12/23/SVM-Concept/","permalink":"http://hexuanweng.github.io/2020/12/23/SVM-Concept/","excerpt":"","text":"SVM - Support Vector Machines The shortest distance between the observations and the threshold is called the margin. The distances between the observations and the threshold are the same and both reflect the margin. When the threshold is halfway between the two observations, the margin is as large as it can be observation: records on the tables&#x2F;rows Maximal Margin Classifier: when we use the threshold that gives us the largest margin to make classifications Maximal Margin Classifiers are super sensitive to outliers in the training data and that makes them pretty lame Soft Margin: when we allow misclassifications, the distance between the observations and the threshold is called soft margin To make a threshold that is not so sensitive to outliers we must allow misclassifications choosing a threshold that allows a misclassifications is an example of the Bias&#x2F;Variance Tradeoff. In other words, before we alloed misclassifications, we picked a threshold that was very sensitive to the training data (low bias) and it performed poorly when we got new data (high variance) In contrast, when we picked a threshold that was less sensitive to the training data and allowed misclassifications (higher bias) but it performed better when we got new data (low variance) How to determin which Soft Margin we use cross validation to determine how many classifications and observations to allow inside of the Soft Margin to get the best classification when we use a Soft Margin to determine the location of a threshold, then we are using a Soft Margin Classifier aka a Support Vector Classifier to classify observations the name Support Vector Classifier comes from the fact that the observations on the edge and within the Soft Margin are called Support Vectors when the data are 2-Dimentional, the Support Vector Classifier forms a line when the data are 3-Dimentional, the Support Vector Classifier forms a plane instead of a line, and we classify new observations by determining which side of the plane they are on. all flat affine subspaces are called hyperplanes Support Vector Classifier can handle outliers allow misclassifications handle overlapping classifications Support Vector Machines start with data in a relatively low dimension move the data into a higher dimension find a Support Vector Classifier that separates the higher dimensional data into two groups Question: How to transform data from low dimension to higher dimension? In order to make the mathematics possible, Support Vector Machines use something called Kernel Functions to systemaically find Support Vector Classifiers in higher dimensions Polynomial Kernel it systematically increases dimensions by setting d, the degree of the polynomial and the relationships between each pair of observations are used to find a Support Vector Classifier we can find a good value for d with Cross Validation Radial Kernel aka Radial Basis Function (RBF) Kernel it finds Support Vector Classifiers in infinite dimensions when using it on a new observation, the Radial Kernel behaves like a Weighted Nearest Neighbour model. The closest observations aka the nearest neighours have a lot of influence on how we classify the new observation and the observations that are further away have relatively little influence on the classification Kernel Functions only calculate the relationships between every pair of points as if they are in the higher dimensions; they don’t actually do the transformation. This trick, calculating the high dimensional relationships without actually transforming the data to the higher dimensions, is called The Kernel Trick The Kernel Trick reduces the amount of computation required for Support Vector Machines by avoiding the math that transforms the data from low to high dimensions and it makes calculating relationships in the infinite dimensions used by the Radial Kernel possible The Polynomial Kernel Formula: (a*b+r)^d a and b refer to two different observations in the dataset r determines the coefficient of the polynomial d sets the degree of the polynomial r and d are determined using Cross Validation Dot Product the first terms multiplied together (x axis) + the second therms multiplied together (y axis) + the third terms multiplied together (z axis) the dot product gives us the high-dimensional coordinates for the data Polynomial Kernel computes relationships between pairs of observations once we deicde on values for r and d, we just plug in the observations and do the math to get the high-dimensional relationships The Radial Kernelaka the Radial Basis Function, RBF Formula: &#x3D; high-dimensional relationships a and b refer to two different observations in the dataset the difference between the measurements is then squared, giving us the squared distance between the two observations the amount of influence one observation has on another is a function of the squared distance gamma, which is determined by Cross Validation, scales the squared distance, and thus, it scales the influence the further two observations are from each other, the less influence they have on each other Just like with the Polynomial Kernel, when we plug values into the Radial Kernel, we get the high-dimensional relationship Based on the Taylor Series Expansion, we can see when we plug numbers into the Radial Kernel and do the math. The value we get at the end is the relationship between the two points in infinite-dimensions Taylor Series Expansion Based on The Radial KernelTaylor Series: f(x) can be split into an infinite sum a can be any value as long as f(a) exists set gamma as 1&#x2F;2, and let’s create the Taylor Series Expansion of this last term the derivative of e^x &#x3D; e^x set x0 &#x3D; 0 when we added up a bunch of Polynomial Kernels with r&#x3D;0 and d going from 0 to infinity, we got a Dot Product with coordinates for an infinite number of dimensions Thus each term in this Taylor Series Expension contains a Polynomial Kernel with r&#x3D;0 and d going from 0 to infinity Dot Product for e^ab is we can verify that the Dot Product is correct by multiplying each term together add up the new terms to get the Taylor Series Expansion of e^ab we just multiply both parts of the Dot Product by the square root of this term we see that the Radial Kernel is equal to a Dot Product that has coordinates for an infinite number of dimensions Maclaurine’s seriesA Maclaurin Series is a Taylor Series where a &#x3D; 0 1.Support Vector Machines, Main Ideas ↩2.Support Vector Machines Part 2: The Polynomial Kernel ↩3.Support Vector Machines Part 3: The Radial (RBF) Kernel ↩","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://hexuanweng.github.io/categories/Data-Science/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://hexuanweng.github.io/tags/Machine-Learning/"},{"name":"video course","slug":"video-course","permalink":"http://hexuanweng.github.io/tags/video-course/"},{"name":"Support Vector Machine","slug":"Support-Vector-Machine","permalink":"http://hexuanweng.github.io/tags/Support-Vector-Machine/"}]},{"title":"Machine Learning Foundation Concept","slug":"Machine-Learning","date":"2020-12-22T09:50:24.000Z","updated":"2020-12-22T09:50:24.000Z","comments":true,"path":"2020/12/22/Machine-Learning/","permalink":"http://hexuanweng.github.io/2020/12/22/Machine-Learning/","excerpt":"","text":"A Gentle Introduction to Machine Learning the goal of Machine Learning is to make predictions classifications two main ideas about ML: we use testing data to evaluate Machine Learning methods don’t be fooled by how well a Machine Learning method fits the Training Data Fitting the Training Data well but make poor predictions is called Bias-Variance Tradeoff There are tons of fancy Machine Learning methods, but the most important thing is to know abou them is not what makes them so fancy, it is that we decide which method fits our needs the best by using Testing Data Cross Validation Cross Validation allows us to compare different machine learning methods and get a sense of how well they will work in practice Four-Fold Cross Validation: divide the data into 4 blocks (numbers change dynamically). In practice, it is very common to divide the data into 10 blocks–Ten-Fold-Cross Validation Leave One Out Cross Validation: call each individual patient (or sample) a block Using machine learning lingo, we need the data to train the machine learning methods test the machine learning methods Reusing the same data for both training and testing is a bad idea because we need to know how the method will work on data it was not trained on. A slightly better idea would be to use the first 75% of the data for training and the last 25% of the data for testing. Rather than worry too much about which block would be best for testing, cross validation uses them all, one at a time, and summarizes the results at the end. Tuning parameter: a parameter that is not estimated, but just sort of guessed. Then we could use 10-fold cross validation to help find the best value for that tuning parameter. The Confusion Matrix steps: we start by dividing the data into Training and Testing set Then we train all of the methods we are interested in with the Training data And then test each method on the Testing set summarize how each method performed on the Testing data create a Confusion Matrix for each method Confusion Matrix rows: what the machine learning algorithm predicted columns: the known truth the result is (Positive&#x2F;Negative) and (True&#x2F;False) shows whether they predict right or wrong diagonal the numbers along the diagonal (top-left, right-bottom) tell us how many times the samples were correctly classified the number not on the diagonal are samples the algorithm messed up the size of the confusion matrix is determined by the number of things we want to predict a Confusion Matrix tells you what your machine learning algorithm did right and what it did wrong Sensitivity and Specificity 2 rows and 2 columns Sensitivity: tells us what percentage of items with some certain features were correctly identified True Positives &#x2F; (True Positives + False Negatives) Specificity: tells us what percentage of items without some certain features were correctly identified True Negatives &#x2F; (True Negatives + False Positives) larger confusion matrices the big difference when calculating Sensitivity and Specifity for larger confusion matrices is that there are no single values that work for the entire matrix, instead we calculate a different Sensitivity and Specificity for each category we can use Sensetivity and Specificity to help us decide which machine learning method would be best for our data If correctly identifying positives is the most important thing to do with the data, we should choose a method with higher sensitivity If corretly identifying negatives is more important, than we should put more emphasis on specificity Machine Learning Models SVM - Support Vector Machines 1.Machine Learning ↩","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://hexuanweng.github.io/categories/Data-Science/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://hexuanweng.github.io/tags/Machine-Learning/"},{"name":"video course","slug":"video-course","permalink":"http://hexuanweng.github.io/tags/video-course/"}]},{"title":"Statistics Foundation Concept","slug":"Statistics-Fundation","date":"2020-12-21T08:20:11.000Z","updated":"2020-12-21T08:20:11.000Z","comments":true,"path":"2020/12/21/Statistics-Fundation/","permalink":"http://hexuanweng.github.io/2020/12/21/Statistics-Fundation/","excerpt":"","text":"HistogramHistograms are one of the most basic statistical tools that we have. divide into bins: the taller the stack within a bin, the more measurements we made that fall into that bin. (figure out how wide is the bin is a tricky) we can use histogram to predict the probability of getting future measurements If you want to use a “distribution” to approximate your data (or future measurements). Histograms are a good way to justify your decision. normal distribution exponential distribution Distribution we can use a curve to approximate the histogram. The curve tells us the same thing that the histogram tells us. advantage over Histogram we can use the curve to calculate the probability the curve is not limited by the width of the bins if we don’t have enough time or money to get a ton of measurements. The approximate curve (based on the mean and standard deviation of the data we were able to collect), is usually good enough both the histogram and the curve are Distributions show us how the probabilities of measurements are distributed. The Normal Distribution Normal&#x2F;Gaussian distribution: it is also called a “bell shaped curve” because it is a symmetrical curve To draw a normal distribution, you need to know: The average measurement. This tells you where the center of the curve goes The standard deviation of the measurements, this tells you how wide the curve should be. And the width of the curve determines how tall it is. The wider the curve the shorter. The narror the curve, the taller. The Central Limit Theorem the normal distribution is kind of magical in that we see it a lot in nature. But there is a reason for that, and that reason makes it super useful for statistics as well. Population Parameters Population: whatever unit it is you are measuring something awesome Population parameters: the parameters that determine how a distribution fits the population data Normal distribution The mean and standard deviation of the normal curve, which represents the population, are called Population parameters population Mean population Standard DeviationExponential Distribution we could use the exponential distribution to calculate probabilities and statistics just like when we had a Normal Distribution population rateGamma Distribution two parameters: population shape population rate the reason why we want to know the population parameters is to ensure that the results drawn from our experiment are reproducible the more data that we have, the more confidence we can have in the accuracy of the estimates. One of the main goals in statistics is quantifying how much confidence we can hsve in population estimates specially, statisticians often calculate p-values and confidence intervals to quantify the confidence in the estimated parameters Estimating the Mean, Variance and Standard Deviation sample mean: statisticians often use the symbol x-bar to refer to the estimated mean &#x3D;&#x3D; sample mean and they use the Greek symbol U(mu) to refer to the population mean The estimated mean is different from the population mean, but with more and more data, x-bar should get closer and closer population variance and standard deviation determine how wide to make the curve we want to calculate how the data are spread around the population mean in the variance the unit is squared. the population variance is the average of the squared differences between the data and the population mean U. we square these differences to prevent the ones on the left from canceling the ones on the right, and then take the average population standard deviation: square root of population variance the standard deviation is the original units that we measured, we can draw it on the graph. estimated population variance change population mean to estimated population mean change n to n-1: dividing by n-1 compensates for the fact that we are calculating differences from the sample mean instead of the population mean estimated population standard deviation square root of estimated population variance Summary if we have all of the data from a population, we can calculate the population mean. when we don’t have the population data, we can estimate the population mean with the same formula when we have the population data, we can calculate the population variance and standard deviation However, we almost never have the population data so chances are you should not use these formulas. Instead, we almost always estimate the variance and standard deviation What is a Model we use models to explore relationships we use statistices to determine how useful and how reliable our model is. Hypothesis Testing, Null Hypothesis and Alternative HypotheseseWe can create a hypothesis, and if data give us strong evidence that the hypothesis is wrong, then we can reject the hypothesis.But when we have data that is similar to the hypothesis, but not exactly the same then the best we can do is fail to reject the hypothesis Null Hypothesis: the hypothesis that is no difference between things the Null Hypothesis does not require preliminary data, because the only value that represents no difference is 0. in the statistical test, it needs three things it needs datas it needs a Null or Primary Hypothesis (i.e. it needs something to reject or fail to reject) it needs alternative hypothesis When we only have two groups of data, the Alternative Hypothesis is pretty obvious because it is simply the opposite of the Null Hypothesis 1.StatQuest with Josh Starmer ↩","categories":[],"tags":[{"name":"video course","slug":"video-course","permalink":"http://hexuanweng.github.io/tags/video-course/"},{"name":"Statistics","slug":"Statistics","permalink":"http://hexuanweng.github.io/tags/Statistics/"}]},{"title":"Google Get Ahead+ Program","slug":"Get-Ahead","date":"2020-11-08T03:10:39.000Z","updated":"2020-11-08T03:10:39.000Z","comments":true,"path":"2020/11/08/Get-Ahead/","permalink":"http://hexuanweng.github.io/2020/11/08/Get-Ahead/","excerpt":"","text":"In September, when I checked my gmail regularly, I noticed one email sent from Google to invite me to express interest in Get Ahead+, which is a Google’s exclusive, invite-only development program. I registered and in few day, I recieved the confirmation email from Google and I am one of the members to study with Google. Get Ahead program Overview and TimelineGet Ahead+ takes place between Monday 7th September to Friday 16th October via live interactive virtual events and group sessions led by Google Engineers with times to be confirmed. The program is designed to run alongside work or study. The time commitment will be approx 2 - 3 hours per week, including Google Meet sessions along with coding challenges throughout the duration of the program and you can work through the material at your own pace. Weekly Email UpdateA weekly email update will be shared with you every Monday throughout the program. It will include a weekly technical challenge, updates about upcoming virtual events and useful links. Each week you’ll have a scheduled group session with a small team of students and Google mentor to discuss the technical challenge, life at Google &amp; much more! The deadline to submit challenge answers will be each Sunday and the Google team will select 1 student at random to win a cool Google swag prize. 😭 Sadly, I am not a lucky dog to be selected during this section. Well, I can get a Google Swag because I submitted all the assignment on time! Yeah~ Looking forward to receiving my Swag! Google Meets EventsGoogle Meets events will be conducted across different topics, one each week. Opening session resume workshop Virtual Go Game Python Interview Workshop The art of clean workshop the 10x thinking workshop Trivia and TGIF Python peer to peer mock interviews Collaborative interviews with Googlers The interview workshops will be in 3 different programming languages including C++, Java and Python where students will solve a problem in real time with a Google engineer. Keep a look out for the calendar invite. Weekly ChallengeI was assigned to Justin‘s group, and the coding language we use is Python. Each week, we have a tutorial session to meet via google meeting to express our opinion on the weekly challenge. Justin guided us to express our own solution to weekly challenge, and then he will provide us with an optimate algorithm to the question. He also helped us to analyze the time and space complexity between different algorithm we selected. Justin has a very cute cat, who sometimes appeared in the tutorial session. 💗 Certificate","categories":[{"name":"Other","slug":"Other","permalink":"http://hexuanweng.github.io/categories/Other/"}],"tags":[{"name":"Google","slug":"Google","permalink":"http://hexuanweng.github.io/tags/Google/"}]},{"title":"DSA - Binary Gap","slug":"Binary-Gap","date":"2020-10-31T13:00:00.000Z","updated":"2020-10-31T13:00:00.000Z","comments":true,"path":"2020/11/01/Binary-Gap/","permalink":"http://hexuanweng.github.io/2020/11/01/Binary-Gap/","excerpt":"","text":"Qeustion A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N.For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps. The number 32 has binary representation 100000 and has no binary gaps.Write a function:class Solution { public int solution(int N); }that, given a positive integer N, returns the length of its longest binary gap. The function should return 0 if N doesn’t contain a binary gap.For example, given N &#x3D; 1041 the function should return 5, because N has binary representation 10000010001 and so its longest binary gap is of length 5. Given N &#x3D; 32 the function should return 0, because N has binary representation ‘100000’ and thus no binary gaps.Write an efficient algorithm for the following assumptions:N is an integer within the range [1..2,147,483,647]. Solution use a list to store the index of each “1” calculate the maximum gapnote: need to omit distance &#x3D;&#x3D; 1~ Python Coding1234567891011121314151617181920def solution(N): one_list = [] res = 0 bin_n = str(format(N, &#x27;b&#x27;)) # get the index list of each one for i in range(len(bin_n)): if bin_n[i] == &#x27;1&#x27;: one_list.append(i) #calculate the largest gap between each index for j in range(len(one_list)-1): distance = one_list[j+1] - one_list[j] if len(one_list) == 1 and j == 0: return 0 elif distance == 1: pass else: if distance &gt; res: res = distance -1 return max(res, 0) Result","categories":[{"name":"Data Structure and Algorithm","slug":"Data-Structure-and-Algorithm","permalink":"http://hexuanweng.github.io/categories/Data-Structure-and-Algorithm/"}],"tags":[{"name":"array","slug":"array","permalink":"http://hexuanweng.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"}]}],"categories":[{"name":"Microsoft Power Platform","slug":"Microsoft-Power-Platform","permalink":"http://hexuanweng.github.io/categories/Microsoft-Power-Platform/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/categories/Leetcode/"},{"name":"Data Science","slug":"Data-Science","permalink":"http://hexuanweng.github.io/categories/Data-Science/"},{"name":"Android Development","slug":"Android-Development","permalink":"http://hexuanweng.github.io/categories/Android-Development/"},{"name":"AWS","slug":"AWS","permalink":"http://hexuanweng.github.io/categories/AWS/"},{"name":"Data Structure and Algorithm","slug":"Data-Structure-and-Algorithm","permalink":"http://hexuanweng.github.io/categories/Data-Structure-and-Algorithm/"},{"name":"Other","slug":"Other","permalink":"http://hexuanweng.github.io/categories/Other/"}],"tags":[{"name":"Power Apps","slug":"Power-Apps","permalink":"http://hexuanweng.github.io/tags/Power-Apps/"},{"name":"medium","slug":"medium","permalink":"http://hexuanweng.github.io/tags/medium/"},{"name":"Recursion","slug":"Recursion","permalink":"http://hexuanweng.github.io/tags/Recursion/"},{"name":"Brute Force","slug":"Brute-Force","permalink":"http://hexuanweng.github.io/tags/Brute-Force/"},{"name":"easy","slug":"easy","permalink":"http://hexuanweng.github.io/tags/easy/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://hexuanweng.github.io/tags/Two-Pointers/"},{"name":"Breadth First Search","slug":"Breadth-First-Search","permalink":"http://hexuanweng.github.io/tags/Breadth-First-Search/"},{"name":"Hashmap","slug":"Hashmap","permalink":"http://hexuanweng.github.io/tags/Hashmap/"},{"name":"Simulation","slug":"Simulation","permalink":"http://hexuanweng.github.io/tags/Simulation/"},{"name":"Greedy","slug":"Greedy","permalink":"http://hexuanweng.github.io/tags/Greedy/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://hexuanweng.github.io/tags/PyTorch/"},{"name":"Topological Sorting","slug":"Topological-Sorting","permalink":"http://hexuanweng.github.io/tags/Topological-Sorting/"},{"name":"Depth First Search","slug":"Depth-First-Search","permalink":"http://hexuanweng.github.io/tags/Depth-First-Search/"},{"name":"hard","slug":"hard","permalink":"http://hexuanweng.github.io/tags/hard/"},{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"http://hexuanweng.github.io/tags/Weekly-Contest/"},{"name":"Stack","slug":"Stack","permalink":"http://hexuanweng.github.io/tags/Stack/"},{"name":"Sorting","slug":"Sorting","permalink":"http://hexuanweng.github.io/tags/Sorting/"},{"name":"Heap","slug":"Heap","permalink":"http://hexuanweng.github.io/tags/Heap/"},{"name":"Math","slug":"Math","permalink":"http://hexuanweng.github.io/tags/Math/"},{"name":"Difference Array","slug":"Difference-Array","permalink":"http://hexuanweng.github.io/tags/Difference-Array/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://hexuanweng.github.io/tags/Sliding-Window/"},{"name":"video course","slug":"video-course","permalink":"http://hexuanweng.github.io/tags/video-course/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://hexuanweng.github.io/tags/Kotlin/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"http://hexuanweng.github.io/tags/Prefix-Sum/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://hexuanweng.github.io/tags/Binary-Search/"},{"name":"Rejection Sampling","slug":"Rejection-Sampling","permalink":"http://hexuanweng.github.io/tags/Rejection-Sampling/"},{"name":"array","slug":"array","permalink":"http://hexuanweng.github.io/tags/array/"},{"name":"AWS Lambda","slug":"AWS-Lambda","permalink":"http://hexuanweng.github.io/tags/AWS-Lambda/"},{"name":"Google BigQuery","slug":"Google-BigQuery","permalink":"http://hexuanweng.github.io/tags/Google-BigQuery/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://hexuanweng.github.io/tags/Leetcode/"},{"name":"AlgoExpert","slug":"AlgoExpert","permalink":"http://hexuanweng.github.io/tags/AlgoExpert/"},{"name":"Notion","slug":"Notion","permalink":"http://hexuanweng.github.io/tags/Notion/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://hexuanweng.github.io/tags/Machine-Learning/"},{"name":"Support Vector Machine","slug":"Support-Vector-Machine","permalink":"http://hexuanweng.github.io/tags/Support-Vector-Machine/"},{"name":"Statistics","slug":"Statistics","permalink":"http://hexuanweng.github.io/tags/Statistics/"},{"name":"Google","slug":"Google","permalink":"http://hexuanweng.github.io/tags/Google/"}]}